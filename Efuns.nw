\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - better decomposition than simple.ml, complex.ml, good TOC
% - removed deadcode (frm_force_point, frm_force_cursor, loc_counter, resname)

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand XXX?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO action
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - SEMI understand main(), LP split main, improve TOC
% - SEMI understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Text Editor Efuns
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}
% add Fabrice?

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a text editor.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% good cos written in ocaml! more high level, and while
% you want to write a kernel in C, it makes more sense for an app 
% to use ocaml!

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item ed
\item vi
\item emacs
%todo: look at emacs lisp manual, and emacs manual to see the concepts
\item qemacs
\end{itemize}

% see Editor.nw for more choices

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from INRIA, so
those parts are copyright by INRIA.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

% Fabrice Le Fessant of course


\chapter{Overview}

\section{Text editor principles}

% "Emacs is the extensible, customizable, self-documenting real-time
% display editor."

% navigating in file (fast, different granularities), random access!
% editing (inserting/deleting/moving/cut-copy-paste/transposing)
% searching, replacing

% efficient keyboard! combination of keys, macros! M-x, C-x o
% everything with keyboard!

% undo! multi steps undo! redo! sessions so macro-level undo
% multi files/buffers, opening/saving/killing switching
% multi windows (a kind of window manager!)

% specialised "major" modes: color, font, indentation, navigating
%todo: semantic editing/visualizing!

%emacs:
% extensible => open source, external commands
% customizable => configuration file
% self-documenting => not really yet? M-x a bit. Have Efuns.nw though :)

% interactive!

% see <<actions definitions>>, pretty good overview of functionalities

% actions activated by = 
% - keyboard (self insert, keybinding, M-x)
% - mouse (menu, window clicks)

\section{[[efuns]] services}

% ./efuns foo.txt

\section{Code organization}

%from guide.txt:

%Internals:
%text.ml: The GAP buffer (self-contained)
%efuns.ml: Types and basic values
%main.ml: The main() function ...
%buffer.ml: Functions to handle buffer structures internals
%frame.ml: Functions to handle frame structures internals
%keymap.ml: Functions to handle keyboard mappings
%window.ml: Handling of simulated text windows
%top_window.ml: Communication with the Xterm widget
%minibuffer.ml: Minibuffer functions
%misc.ml: Useful functions
%str2.ml: Addons to the Str module (replace_matched)
%
%Functions:
%simple.ml: Basic functions (insertion, etc ...)
%complex.ml: More complex functions (with minibuffer)
%abbrevs.ml: Static and Dynamic abbrevs
%system.ml:  Functions to handle external processes
%interactive.ml: Interactive functions handling (M-x)
%parsers.mly: Various useful parsers (/etc/passwd)
%lexers.mll: Various useful lexers (/etc/passwd, filenames)
%compile.ml: Functions for error search after compilation
%search.ml: Searchs and replacements
%time.ml: Time functions
%select.ml: Useful functions to ask the user in the minibuffer
%eval.ml: Dynamic load of external modules (Dynlink)
%multi_frames.ml: Handling of multiple text windows in one Xterm widget
%
%Major modes:
%ocaml_mode.mll: The Ocaml mode
%  ocamlc.ml:  Functions to read .cmi data from the Ocaml compiler
%  printtyp.ml: The type pretty printer from the Ocaml compiler
%tex_mode.mll: The TeX mode
%c_mode.mll: The C mode
%lisp_mode.ml: The Lisp mode (is this really useful ? yes, I use GWM as
%  window-manager :)
%html_mode.mll: The HTML mode
%makefile_mode.ml: The Makefile mode (Tabulation)
%
%Minor modes:
%accents_mode.ml: Accents for QWERTY keyboards (e' => é, e'' => e', ...)
%
%Config:
%std_efunsrc.ml: Standard bindings (except those defined in other modules)


\section{Software architecture}

% the world, location that then encapsulate
%  windows/frames, with buffers, with Text inside
%
% then event loop with keyboard dispatch to the right action and
% right focused frame, taking itself the frame in parameter
%
% redisplay engine.

\section{Loading a file}

% scenario

\section{Trace of a key press}

% keyboard dispatch
% action (e.g. RETURN)
% rerendering!


%###############################################################################

\chapter{Core Data Structures}

% text -> buffer -> frame -> window -> top_window

\section{[[Text]]}

% text -> line -> ... repr | item
% with attrs at each level (text_attr, attr, item_attr)

<<type Text.text>>=
type text = {
    mutable text_string : string;
    mutable text_size : int; (* String.length text.text_string *)

    mutable text_newlines : line array;
    mutable text_nlines : int; (* Array.length text.text_newlines *)
    <<[[Text.text]] other fields>>
  } 
@
% will see line later




<<[[Text.text]] other fields>>=
(* version *)    
mutable text_modified : int;
@
%less: type version = int; ?

<<function Text.version>>=
let version tree = 
  let text = tree.tree_text in
  text.text_modified
@
% tree? because of wx_text stuff


<<function Text.nbre_lines>>=
let nbre_lines tree = 
  let text = tree.tree_text in
  text.text_nlines - 2
@
% - 2? why? because has some empty sentinels?



%ctor
<<function Text.create>>=
let create str =
  let newlines = compute_newlines str in
  let nlines = Array.length newlines in
  let attrs = (Array.create (String.length str) direct_attr) in

  let text =
    {
      text_string = str;
      text_size = String.length str;
      text_newlines = newlines;
      text_nlines = nlines;
      text_attrs = attrs;
      text_modified = 0;
      
      text_points = [];
      text_gpoint = 0;
      text_gline = 0;
      text_gsize = 0;
      text_clean = false;
      text_history = [];
      text_readonly = false;
    }
  in
  make_text text (Array.copy newlines)
@
% was let rec text, weird

% compute_newlines()?
% make_text()?

\section{[[Buffer]]}

%"The buffer corresponds either to a file (thus to a filename) either to
%a virtual file (for example, compilation messages). The file text itself
%is stored in the Text.t type."

<<type Efuns.buffer>>=
(* a buffer containing a file in Text.t *)
and buffer =
  { 
    mutable buf_text : Text.t;

    mutable buf_name : string;
    mutable buf_filename : string option;

    <<[[Efuns.buffer]] other fields>>
  } 
@
% string option because have some buffers like *Messages*
% that are not connected to a file

% diff with Text? 
% - have a name, Text is really just the content.
%    here it's connected to a file. 
% - it has also a buf_point (and later a frame will have a cursor),
%   see below
% - it has a major mode, minor modes, a keymap, local variables
%   see in next chapters


% point is an important notion? y?
<<type Text.point>>=
and point = {
    mutable point : int;
    mutable point_y : int;
  }
@
% not point_x ?
% it's a charpos or a line/col?

<<[[Efuns.buffer]] other fields>>=
mutable buf_point : Text.point;
mutable buf_start : Text.point;
@
% current!
% which will be the save value of frm_point
% when switch between buffer, the current frame is a view
% on different buffer, but when you go back to a buffer you
% want the cursor to be at the same position you used to be
% and the screen at the same starting point.

% there are list of points maintained by the Text itself, why?
% because of gap things can move so you need to update all
% the points?

<<[[Efuns.buffer]] other fields>>=
mutable buf_modified : int;
@
% diff with text_modified? seems to be about modification of the
% frame property itself, not the underlying buffer


<<function Ebuffer.create>>=
let create location name filename text local_map =
  let name = get_name location name in
  let buf =
    { 
      buf_text = text;
      buf_name = name;
      buf_filename = filename;

      buf_point = Text.add_point text;
      buf_start = Text.add_point text;

      buf_last_saved = version text;
      buf_modified = 0;

      buf_charreprs = Array.init 256 (fun i -> String.make 1 (Char.chr i));
      buf_map = local_map;
      buf_map_partial = true;
      buf_syntax_table = default_syntax_table;
      buf_vars = Local.vars ();
      buf_minor_modes = [];
      buf_major_mode = fondamental_mode;

      buf_history = [];
      buf_sync = false;
      buf_mark = None;
      buf_shared = 0;
      buf_finalizers = [];

      buf_location = location;
    } in
  <<[[Ebuffer.create()]] adjust location global fields>>
  <<[[Ebuffer.create()]] adjust charreprs>>
  <<[[Ebuffer.create()]] run hooks>>
  buf
@



\section{[[Frame]]}
% It's not frame in emacs terminology.
% It's really a window, but with not just
%  the geometric info, it packs together geometric info (window type)
%  and buffer info (buffer type)
% The cursor is here! not in the buffer.

% can have different windows/frames over a single buffer.
% convenient so can view different parts of the file at once.

% "A frame is a text window with a buffer inside."

<<type Efuns.frame>>=
(* a frame: a view of a buffer for a window *)
and frame  =
  {
    mutable frm_buffer : buffer;

    mutable frm_xpos : int;
    mutable frm_ypos : int;
    
    mutable frm_width : int;
    mutable frm_height : int;
    <<[[Efuns.frame]] other fields>>
  } 
@
%less: different sections for the frame (cursor, position, etc)
%dead: mutable frm_force_point : bool;
%dead: mutable frm_force_cursor : bool;
%coordinates? seems redundant with frm.frm__window info no?
% xpos are in line x col dimentions, same for width and height,
% not pixels.

<<[[Efuns.frame]] other fields>>=
(* insert point *)
mutable frm_point : Text.point; 
@
% current!
% cursor!

<<[[Efuns.buffer]] other fields>>=
mutable buf_shared : int; (* number of frames for that buffer *)
@


<<function Frame.create_without_top>>=
let create_without_top location window mini buf =
  let width = window.win_width in
  let height = window.win_height in

  let frm_start = Text.dup_point buf.buf_text buf.buf_start in
  let frm_end   = Text.dup_point buf.buf_text buf.buf_start in (* ?? *)
  let point     = Text.dup_point buf.buf_text buf.buf_point in

  buf.buf_shared <- buf.buf_shared + 1;

  <<[[Frame.create_without_top()]] let status>>

  let frame =
    { frm_buffer = buf;
      frm_window = window;

      frm_xpos = window.win_xpos;
      frm_ypos = window.win_ypos;
      frm_width = width;
      frm_height = height;

      frm_start = frm_start;
      frm_end = frm_end;
      frm_point = point;
      frm_x_offset = 0;
      frm_y_offset = 0;

      frm_cursor_x = 0;
      frm_cursor_y = 0;
      frm_cursor = String.make 1 ' ';
      frm_cursor_attr = Text.direct_attr;

      frm_last_text_updated = 0;
      frm_last_buf_updated = 0;

      frm_has_scrollbar = 0;
      frm_has_status_line = 1;
      frm_status = status;
      frm_mini_buffer = mini;
      
      frm_prefix = [];
      
      frm_repeat_action = 0;
      frm_last_action = Keymap.dummy_action;
    
      frm_force_start = false;
      frm_cutline = width - 1;
      frm_table = [||];
      frm_killed = false;
      frm_redraw = true;

      frm_location = location;
    } 
  in
  <<[[Frame.create_without_top()]] adjust status of frame>>

  install window frame;
  frame
@


\section{[[Window]]}
% It's a window in emacs terminology. And it's really
% just the geometry part.


<<type Efuns.window>>=
and window =
  { 
    mutable win_xpos : int;
    mutable win_ypos : int;

    mutable win_width : int;
    mutable win_height : int;

    <<[[Efuns.window]] other fields>>
  } 
@

<<[[Efuns.frame]] other fields>>=
mutable frm_window : window;
@


<<[[Efuns.window]] other fields>>=
mutable win_down : window_down;
mutable win_up : window_up;
@
% up is important, allow to access top_window and 
% top_location from any frame (but could use globals I think)

<<type Efuns.window_down>>=
and window_down =
| WFrame of frame
| NoFrame of unit

| HComb of window * window 
| VComb of window * window
@
%less: why of unit?

<<type Efuns.window_up>>=
and window_up =
  Window of window
| TopWindow of top_window
@


<<function Window.top>>=
let top window = 
  let rec iter window =
    match window.win_up with
      TopWindow top_window -> top_window
    | Window window -> iter window
  in
  iter window
@
% often used then to access the location, but
% not sure why you need that since the location
% is also accessible in the frame and buffer

<<function Window.create>>=
let create mini up_window xpos ypos width height =
  {
  win_xpos = xpos;
  win_ypos = ypos;

  win_width = width;
  win_height = height;

  win_down = NoFrame (); 
  win_up = up_window;

  win_mini = mini;
  }
@



<<function Window.create_at_top>>=
let create_at_top xpos ypos width height =
  let rec window = {
    win_xpos = xpos;
    win_ypos = ypos;
    win_width = width;
    win_height = height;

    win_down = NoFrame (); 
    win_up = Window window;

    win_mini = false;
  } in
  window
@


\section{The [[Top_window]]}
% LPize Topwindow in window_up and put it here

%"The top_window structure corresponds to an Xterm widget (one X window).
%From the top_window structure, you have access to text windows (window type)
%displayed inside the Xterm widget. Windows are organized as a binary tree,
%where branchs are either horizontal or vertical combinaisons, and leaves are
%frames (frame window). A frame is a text window with a buffer inside."


<<type Efuns.top_window>>=
(* an xterm: a window containing some frames *)
and top_window = 
  { 
    mutable top_name : string;

    mutable top_width : int;
    mutable top_height : int;

    mutable window : window;

    <<[[Efuns.top_window]] other fields>>
  } 
@
% top_height includes minibuffer line.
% diff with window? no xpos, ypos here
% old: used to have a top_windows with an 's' but a bit weird,
%  and also to use top_windows where really it's windows,
%  so I renamed this field 'window' even though then it
%  breaks the conventions of having those top_xxx prefix

<<[[Efuns.top_window]] other fields>>=
mutable top_display : string option (*WX_xterm.xterm_display option*);
mutable top_xterm : unit option (* WX_xterm.xterm_window option *);
@
%(*
%mutable top_root : WX_root.t;
%mutable top_appli : WX_appli.t;
%mutable top_scrollbar : WX_adjust.t;
%mutable top_term : WX_xterm.t;
%top_attrs : WX_xterm.xterm_gc option array;
%*)

<<[[Efuns.top_window]] other fields>>=
mutable top_active_frame : frame;
@
%current!



\section{The world, [[Location]]}
% full state

% called location in Lefessant's terminology

%"All the editor information is organised inside one structure: the location.
%The location grants access to all other structures inside the editor. This
%is done to easily save the editor state after a session (or to move it
%from one editor to another)."


%(* the world *)
<<type Efuns.location>>=
and location =
  { 
    (* key is buffer name *)
    mutable loc_buffers : (string, buffer) Hashtbl.t;
    (* key is filename *)
    mutable loc_files : (string, buffer) Hashtbl.t;

    (* list??*)
    mutable top_windows : top_window list;

    (* pwd of efuns when started *)
    mutable loc_dirname : string;

    (* general look, configurable via -xxx command line options or .efunsrc *)
    mutable loc_width : int;
    mutable loc_height : int;

    mutable loc_fg : string;
    mutable loc_bg : string;
    mutable loc_font : string;

    <<[[Efuns.location]] other fields>>
  } 
@
%(*    
%    loc_vars_table : (string, (Obj.t -> string) * (string -> Obj.t)) Hashtbl.t;
%  *)  
%dead: mutable loc_counter : int;
%old: was loc_windows, but it's really top_windows

% head of list is current?

<<[[Ebuffer.create()]] adjust location global fields>>=
Hashtbl.add location.loc_buffers name buf;
@



<<[[Efuns.buffer]] other fields>>=
buf_location : location;
@
<<[[Efuns.frame]] other fields>>=
mutable frm_location : location;
@
<<[[Efuns.top_window]] other fields>>=
mutable top_location : location;
@

%so can access the global world info from a frame
%todo: but what if location was global, then even easier
% to access global info


<<[[Efuns.location]] other fields>>=
loc_mutex : Mutex.t;
@
% have multiple threads? need mutual exclusion?



\section{[[Action]], and [[actions]]}

<<type Efuns.action>>=
and action = frame -> unit
@

<<type Efuns.generic_action>>=
and generic_action =
  BufferAction of (buffer -> unit)
| FrameAction of (frame -> unit)
@
% really need this BufferAction subtelity?
% We need a buffer action when something is done only once, e.g.
% setting up the major mode is a buffer operation and buffer property!
% A frame is more temporary

<<global Efuns.actions>>=
let (actions : (string, generic_action) Hashtbl.t) = 
  Hashtbl.create 63
@
% global!!
% for M-x! and also so can use string in keybinding or mouse
% (but could maybe use dirrectly the ocaml action code)


<<function Efuns.define_action>>=
let define_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (FrameAction action_fun)
@

<<function Efuns.define_buffer_action>>=
let define_buffer_action action_name action_fun =
  <<sanity check action defined twice>>
  Hashtbl.add actions action_name (BufferAction action_fun)
@

<<sanity check action defined twice>>=
(try ignore (Hashtbl.find actions action_name);
    Printf.printf "Warning: action \"%s\" defined twice" action_name;
    print_newline ();
  with _ -> ());
@


%<<constant Efuns.no_action>>=
%let no_action = BufferAction (fun _ -> ())
%@
<<function Efuns.get_action>>=
let get_action action =
  try Hashtbl.find actions action 
  with Not_found -> BufferAction (fun _ -> ())
@

% ?? -> <> who will dispatch and know which frame?
% string -> ocaml code
<<function Efuns.execute_action>>=
let execute_action action frame = 
  match (get_action action) with
    BufferAction f -> f frame.frm_buffer
  | FrameAction f -> f frame 
@

% exec_named_buf_hooks -> <>
<<function Efuns.execute_buffer_action>>=
let execute_buffer_action action buf =
  match (get_action action) with
    BufferAction f -> f buf
  | FrameAction f -> 
      Printf.printf "Can't apply action %s on buffer" action;
      print_newline ()
@


<<function Keymap.dummy_action>>=
let dummy_action frame = () 
@


<<toplevel Std_efunsrc._1>>=
let _ =
  <<actions definitions>>
  ()
@


<<actions definitions>>=
(* ----------------------------------------------------------- *)
(* Loading *)
(* ----------------------------------------------------------- *)
<<loading actions>>

(* ----------------------------------------------------------- *)
(* Navigating (in the file) *)
(* ----------------------------------------------------------- *)
<<navigating actions>>

(* ----------------------------------------------------------- *)
(* Editing *)
(* ----------------------------------------------------------- *)
(* ------------------------- *)
(* Inserting *)
(* ------------------------- *)
<<inserting actions>>
(* ------------------------- *)
(* Deleting *)
(* ------------------------- *)
<<deleting actions>>
(* ------------------------- *)
(* Moving (Cut, copy, paste) *)
(* ------------------------- *)
<<moving actions>>
(* ------------------------- *)
(* Transforming *)
(* ------------------------- *)
<<transforming actions>>
(* ------------------------- *)
(* Replacing *)
(* ------------------------- *)
<<replacing actions>>

(* ----------------------------------------------------------- *)
(* Searching *)
(* ----------------------------------------------------------- *)
<<searching actions>>

(* ----------------------------------------------------------- *)
(* Undoing *)
(* ----------------------------------------------------------- *)
<<undoing actions>>

(* ----------------------------------------------------------- *)
(* External commands *)
(* ----------------------------------------------------------- *)
<<external command actions>>

(* ----------------------------------------------------------- *)
(* Buffers/windows/frames *)
(* ----------------------------------------------------------- *)
<<buffer managment actions>>
<<buffer navigating actions>>
<<frame managment actions>>
<<frame navigation actions>>

(* ----------------------------------------------------------- *)
(* Meta *)
(* ----------------------------------------------------------- *)
<<meta actions>>

(* ----------------------------------------------------------- *)
(* Saving *)
(* ----------------------------------------------------------- *)
<<saving actions>>

(* ----------------------------------------------------------- *)
(* Major mode *)
(* ----------------------------------------------------------- *)
<<major mode actions>>

(* ----------------------------------------------------------- *)
(* Misc *)
(* ----------------------------------------------------------- *)
<<misc actions>>
@


%XXX
<<misc actions>>=
define_action "save_options" save_options;
define_action "get_position" get_pos;
define_action "unset_attr" unset_attr;
define_action "recenter"  recenter;
define_action "revert_buffer" reload;
(* C-x map *)
define_action "point_at_mark"  point_at_mark;
(* C-M map *)
define_action "next_hole" next_hole;
define_action "open_display" open_display;
(* C-x map *)
define_action "change_font"  change_font;
@  
%(*  define_action "load_library" load_library;*)
%(*  define_action "start_server" Server.start;  *)

<<misc actions>>=
<<window managment actions>>
@


\section{Keyboard [[Map]]}
% keyboard handling is important for an editor!
% emacs spirit: prefix map
% vi spirit: modes
% sam spirit: the mouse ...

% mv stuff in Keyboard section? what is necessary to see before?

% like for variables, have different maps for different "scopes":
% - global
% - major mode
% - minor mode
% - buffer itself (useful for dynamic setting of keys e.g. C-g in minibuffer)
% good so that each mode can redefine bindings! specialized mode!
% specialized keys! For instance when TAB to offer completion
% in minibuffer mode, or semantic completion in C buffer, or just
% insert a TAB in makefile mode.

<<type Efuns.map>>=
type map =
  { 
    (* 256 array, one character simple key = one action *)
    char_map : binding array;
    (* complex key, possible sub maps *)
    mutable complex_bindings : (key * binding) list;

    <<[[Efuns.map]] other fields>>
  } 
@
% char_map is essentially an optimisation, so that simple key
% dispatching goes quickly

<<type Efuns.key>>=
and key = mod_ident * keySym
@

<<type Efuns.mod_ident>>=
and mod_ident = 
  NormalMap
| ControlMap
| MetaMap
| ControlMetaMap
@

%(*Xtypes.*)
<<type Efuns.keySym>>=
and keySym = int
@
% keySym = int (could be a Rune in plan9!)


<<type Efuns.binding>>=
and binding = 
  Function of action
| Prefix of map
| Unbound
@
% mutually recursive type! find map again

<<function Keymap.create>>=
let create () =
  { char_map = Array.create 256 Unbound;
    complex_bindings = [];
    interactives = [];
  } 
@
% will see interactives later

<<[[Efuns.buffer]] other fields>>=
buf_map : map;
@

<<[[Efuns.location]] other fields>>=
loc_map : map;
@


<<function Ebuffer.get_binding>>=
let get_binding buf keylist =
  let binding = ref Unbound in
  try
    <<[[Ebuffer.get_binding()]] minor mode key search>>
    <<[[Ebuffer.get_binding()]] major mode key search>>
    (let b = Keymap.get_binding buf.buf_map keylist in
      match b with
      | Prefix _map -> binding := b;
      | Function _f -> binding := b; raise Exit
      | Unbound -> ()
    );
    <<[[Ebuffer.get_binding()]] if partial map>>
    !binding
  with
    Exit -> !binding
@
% see Keymap.get_binding later *)


%\section{Partial maps}
<<[[Efuns.buffer]] other fields>>=
mutable buf_map_partial : bool;
@
% but always true no?
<<[[Ebuffer.get_binding()]] if partial map>>=
if buf.buf_map_partial then
  (let b = Keymap.get_binding buf.buf_location.loc_map keylist in
    match b with
      Prefix map -> binding := b;
    | Function f -> binding := b; raise Exit
    | Unbound -> ()
  );
@





<<function Keymap.add_global_key>>=
let add_global_key location = 
  interactive location.loc_map 
@
<<function Keymap.add_local_key>>=
let add_local_key buf = 
  interactive buf.buf_map 
@
% each major mode can then use those primitives to offer
% a specialized experience!

% add_local_key | add_global_key | ...-> <>?
<<function Keymap.interactive>>=
let interactive map   keylist name f =
  <<[[Keymap.interactive()]] add keylist and name to interactives list>>
  add_binding map keylist f
@
%less: rename? add_key_binding_and_interactive_name?
% see Keymap.add_binding later *)








<<constant Std_efunsrc.global_map>>=
let global_map = define_option ["global_map"] "" (list_option binding_option) []
@

<<constant Simple.binding_option>>=
let binding_option = tuple2_option (smalllist_option key_option, string_option)
@
<<constant Simple.key_option>>=
let key_option = define_option_class "Key" value_to_key key_to_value
@


<<toplevel Std_efunsrc._2>>=
let _ = 
  if !!global_map = [] then begin
      global_map =:= [
        <<[[global_map]] initial entries>>
      ]
    end;
  <<[[Std_efunsrc.toplevel]] set interactives_map>>
@

% a few shortcuts

%\section{[[C-h]]}
<<constant Keymap.c_h>>=
let c_h = (ControlMap, Char.code 'h')
@
<<constant Std_efunsrc.c_h>>=
let c_h = (ControlMap, Char.code 'h')
@
%\section{[[C-x]]}
<<constant Keymap.c_x>>=
let c_x = (ControlMap, Char.code 'x')
@
<<constant Std_efunsrc.c_x>>=
let c_x = (ControlMap, Char.code 'x') 
@
%\section{[[C-c]]}
<<constant Keymap.c_c>>=
let c_c = (ControlMap, Char.code 'c')
@
<<constant Std_efunsrc.c_c>>=
let c_c = (ControlMap, Char.code 'c') 
@


<<[[global_map]] initial entries>>=
(* -------------------------------------------------------- *)
(* Loading *)
(* -------------------------------------------------------- *)
<<loading keys>>

(* -------------------------------------------------------- *)
(* Navigating (in the file) *)
(* -------------------------------------------------------- *)
<<navigating keys>>

(* -------------------------------------------------------- *)
(* Editing *)
(* -------------------------------------------------------- *)
(* ------------- *)
(* Inserting *)
(* ------------- *)
<<inserting keys>>
(* ------------- *)
(* Deleting *)
(* ------------- *)
<<deleting keys>>
(* ------------------------------ *)
(* Moving (Cut, copy, paste) *)
(* ------------------------------ *)
<<moving keys>>
(* ---------------------- *)
(* Transforming *)
(* ---------------------- *)
<<transforming keys>>
(* ---------------------- *)
(* Replacing *)
(* ---------------------- *)
<<replacing keys>>

(* -------------------------------------------------------- *)
(* Searching *)
(* -------------------------------------------------------- *)
<<searching keys>>

(* -------------------------------------------------------- *)
(* Undoing *)
(* -------------------------------------------------------- *)
<<undoing keys>>

(* -------------------------------------------------------- *)
(* External commands *)
(* -------------------------------------------------------- *)
<<external commands keys>>

(* -------------------------------------------------------- *)
(* Buffers/windows/frames *)
(* -------------------------------------------------------- *)
<<buffer managment keys>>
<<buffer navigating keys>>
<<frame managment keys>>
<<frame navigation keys>>

(* -------------------------------------------------------- *)
(* Meta *)
(* -------------------------------------------------------- *)
<<meta keys>>

(* -------------------------------------------------------- *)
(* Saving *)
(* -------------------------------------------------------- *)
<<saving keys>>

(* -------------------------------------------------------- *)
(* Misc *)
(* -------------------------------------------------------- *)
<<misc keys>>
@

%XXX
<<misc keys>>=
[NormalMap, XK.xk_Insert], "overwrite_mode";
[ControlMap, Char.code 'l'], "recenter";

[c_x; NormalMap, Char.code 'F'], "change_font";
[c_x; ControlMap, Char.code 'x'], "point_at_mark";
[ ControlMap, Char.code 'c'; NormalMap, Char.code '-'], "next_hole";
@


<<misc keys>>=
<<window managment keys>>
@



<<misc keys>>=
[c_h; NormalMap, Char.code 'K'], "help_bindings";
@
<<misc actions>>=
(* C-h map *)
define_action "help_bindings"  Frame.bindings_help;
@

<<function Frame.bindings_help>>=
let bindings_help frame =
  let window = frame.frm_window in
  change_buffer window "*bindings*"
@
% how can change_buffer with just window info? don't pass the frame?
% no need because can go back to top_window and active_frame?



% start_hook -> (Std_efunsrc._5 -> add_start_hook(<>) )
<<function Std_efunsrc.init_global_map>>=
let init_global_map location = 
  List.iter (fun (keys, action) ->
      try
        Keymap.add_global_key location keys action (execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  ) !!global_map;

  <<[[Std_efunsrc.init_global_map()]] add interactives from interactives_map>>
    
  (* standard keys *)

  (* Mouse *)
  <<[[Std_efunsrc.init_global_map()]] mouse keys setup>>
  ()
@

%  Keymap.add_global_key location [NormalMap, XK.xk_dead_circumflex]
%    "circumflex" (char_insert_command '^');
%dead:  let gmap = location.loc_map in 


\section{[[Vars]]}
% actually have polymorphic variables!
% trick using phantom types?

% put more of local.ml here?

% why need variables anyway in emacs? to configure things! e.g. level
% of indentation for this major mode. You can overwrite also
% global settings. Configurable editor!

<<[[Efuns.buffer]] other fields>>=
(* see also Loc.vars *)    
mutable buf_vars : vars;
@
% vars defined in ? local.mli?

<<[[Efuns.location]] other fields>>=
loc_vars : vars;
@

% different scopes:
% - global
% - buffer
% - major mode
% - minor mode

<<function Efuns.set_global>>=
let set_global location var value = Local.set location.loc_vars var value
@

<<function Efuns.set_local>>=
let set_local buf var value = Local.set buf.buf_vars var value
@

<<function Efuns.get_global>>=
let get_global location var = Local.get location.loc_vars var
@
%todo: put the type of the .mli here? subtle signature. polymorphic vars!

<<function Efuns.get_local>>=
let get_local buf var = Local.get buf.buf_vars var
@

% buffer -> major -> minors -> global
<<function Efuns.get_var>>=
let get_var buf var = 
  try Local.get buf.buf_vars var 
  with Not_found ->
    try 
      <<[[Efuns.get_var()]] try with major mode variables>>
    with Not_found ->
      try 
        <<[[Efuns.get_var()]] try with minor mode variables>>
      with Not_found ->
          Local.get buf.buf_location.loc_vars var
@




\section{Hooks}
% essentially a set of list refs

% different kind of hooks:
% - startup hooks (add_start_hook() and start_hooks[] and Efuns.init())
%    will see in main chapter.
% - variable hook, below
% - named hooks, for frame a buffer actions, so take a string (action name)
%   for parameter

% again, configurable editor spirit so hooks to customize things,
% place where you can plug a customization at certain code points

<<function Efuns.exec_hooks>>=
let rec exec_hooks hooks arg =
  match hooks with
    [] -> ()
  | f :: hooks -> 
      (try f arg with _ -> ());
      exec_hooks hooks arg
@

<<function Efuns.add_hook>>=
let add_hook location hook_var hook =
  let tail = try get_global location hook_var with _ -> [] in
  set_global location hook_var (hook :: tail)
@



% example:
% of a hook var. What is the type of create_buf_hook? and get_global below?
<<constant Ebuffer.create_buf_hook>>=
let create_buf_hook = Local.create_abstr "create_buf_hook"
@
%less: remame create_buffer_hooks? more consistent?
% of use of this hook var
<<[[Ebuffer.create()]] run hooks>>=
let hooks = try get_global location create_buf_hook with Not_found -> [] in
exec_hooks hooks buf;
@






<<function Frame.exec_named_hooks>>=
let rec exec_named_hooks hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_hooks hooks frame;
      try execute_action action frame with _ -> ()
@

<<function Frame.exec_named_hooks_with_abort>>=
let rec exec_named_hooks_with_abort hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_hooks_with_abort hooks frame;
      execute_action action frame
@

% example:
<<constant Frame.change_buffer_hooks>>=
let change_buffer_hooks = define_option ["change_buffer_hooks"] "" 
    (list_option string_option)
  [ "check_file" ]
@
% use?

<<misc actions>>=
define_action "check_file" check_file;
@


% ?? -> <>
<<function Ebuffer.exec_named_buf_hooks>>=
let rec exec_named_buf_hooks hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_buf_hooks hooks frame;
      try execute_buffer_action action frame with _ -> ()
@

% ?? -> <>
<<function Ebuffer.exec_named_buf_hooks_with_abort>>=
let rec exec_named_buf_hooks_with_abort hooks frame =
  match hooks with
    [] -> ()
  | action :: hooks ->
      exec_named_buf_hooks_with_abort hooks frame;
      execute_buffer_action action frame
@


% example:
<<constant Ebuffer.save_buffer_hooks>>=
let save_buffer_hooks = define_option ["save_buffer_hooks"] "" 
    (list_option string_option)
  [ ]
@
% use

\chapter{[[main()]]}
% there is actually no really main() in ocaml, instead
% a list of toplevels doing stuff (in the order of the linking)

%\section{General style parameters}
 
<<constant Efuns.width>>=
let width = define_option ["width"] "" int_option 80
@

<<constant Efuns.height (core/efuns.ml)>>=
let height = define_option ["height"] "" int_option 25
@

%<<constant Efuns.height>>=
%let height = ref 27
%@
%redundant?

<<constant Efuns.foreground>>=
let foreground = define_option ["foreground"] "" string_option "white"
@

<<constant Efuns.background>>=
let background = define_option ["background"] "" string_option "black"
@

<<constant Efuns.font>>=
let font = define_option ["font"] "" string_option "fixed"
@




% init files are not the .efunsrc, but the first set of files to open
% so when do efuns foo.c => init_files = ref ["foo.c"]
<<constant Efuns.init_files>>=
let init_files = ref []
@
% should be used in Graphic.init

<<toplevel Efuns._3>>=
let _ =
 Arg.parse [
   <<[[main()]] command line options>>
 ] 
 (fun name -> init_files := name :: !init_files) 
 "A small editor entirely written in Objective Caml 
  by Fabrice LE FESSANT, INRIA Rocquencourt, FRANCE
  http ://pauillac.inria.fr/efuns
  Options :
 " 
@



\section{Arguments processing}

<<constant Efuns.width_opt>>=
let width_opt = ref None
@

<<constant Efuns.height_opt>>=
let height_opt = ref None
@

<<constant Efuns.font_opt>>=
let font_opt = ref None
@

<<constant Efuns.fg_opt>>=
let fg_opt = ref None
@

<<constant Efuns.bg_opt>>=
let bg_opt = ref None
@

% actually it's in Efun._3
<<[[main()]] command line options>>=
"-fg", Arg.String(fun s -> fg_opt :=Some s), "<color>: Foreground color";
"-bg", Arg.String(fun s -> bg_opt :=Some s), "<color>: Background color";

"-font", Arg.String(fun s -> font_opt :=Some s), "<font>: Font name";
"-width", Arg.Int (fun i -> width_opt := Some i), "<len>: Width in chars";
"-height", Arg.Int (fun i -> height_opt := Some i), "<len>: Height in chars";
@

<<toplevel Efuns._5>>=
let _ =
  (match !fg_opt with None -> () | Some color -> foreground =:= color);
  (match !bg_opt with None -> () | Some color -> background =:= color);
  (match !font_opt with None -> () | Some color -> font =:= color);
  (match !width_opt with None -> () | Some color -> width =:= color);
  (match !height_opt with None -> () | Some color -> height =:= color)  
@




%x11
<<constant Efuns.displayname>>=
let displayname = ref ""
@
<<[[main()]] command line options>>=
"-d", Arg.String(fun s -> displayname := s),"<dpy>: Name of display";
"--display", Arg.String(fun s -> displayname := s),"<dpy>: Name of display";
@


<<constant Efuns.check>>=
let check = ref false
@
<<[[main()]] command line options>>=
"-check", Arg.Set check, ": only for testing";
@





<<constant Efuns.init_frames>>=
let init_frames = ref []
@
<<[[main()]] command line options>>=
  "-frame", Arg.String (fun s -> init_frames := s:: !init_frames), "<file>: open a frame with <file>";
@
%todo: remove? seems related to original notion of emacs frames
% that is independent emacs windows

% (*    "-c", Arg.String Dyneval.compile,"<file.ml>: compile file";*)




\section{Configuration file, [[.efunsrc]]}

<<constant Efuns.no_init>>=
let no_init = ref false
@
% dead?
<<[[main()]] command line options>>=
  "-q", Arg.Set no_init,": Don't load init files";
@



% see appendix on configuration file library
<<toplevel Efuns._4>>=
let _ =
  Options.filename := 
   (try Utils.find_in_path (Utils.homedir :: !!load_path) ".efunsrc" 
    with _ -> Filename.concat Utils.homedir ".efunsrc");
  (try Options.init () with _ -> ())
@

\section{The default world, [[location]]}

<<constant Main.location>>=
let location = {
    loc_buffers = Hashtbl.create 13;
    loc_files = Hashtbl.create 13;

    top_windows = [];

    loc_width = !!width;
    loc_height = !!height;
    loc_fg = !!foreground;
    loc_bg = !!background;
    loc_font = !!font;

    loc_map = Keymap.create ();
    loc_dirname = Sys.getcwd ();

    loc_vars = Local.vars ();
    
    loc_fonts = Hashtbl.create 37;
    loc_fonts_names = Array.create 256 "";
    loc_fonts_n = 0;

    loc_colors = Hashtbl.create 37;
    loc_colors_names = Array.create 256 "";
    loc_colors_n = 0;
    
    loc_mutex = Mutex.create ()
} 
@
%less: need those loc_fonts_xxx and loc_colors_xxx?

\section{Startup hooks}
% hooks on location creation, hence they they a location in parameter

<<toplevel Main._3>>=
let _ =
  Efuns.init location (* launch first hooks *)
@

% main.ml -> <>
<<function Efuns.init>>=
let init (location : location) =
  let rec iter hooks =
    match hooks with
      [] -> ()
    | (f : location -> unit) :: hooks -> 
        f location;
        iter hooks
  in
  let hooks = List.rev !start_hooks in
  start_hooks := [];
  iter hooks
@
%less: why not using exec_hooks?
%less: why not just List.iter (fun f -> f ()) hook?



% init -> List.iter run <>
<<constant Efuns.start_hooks>>=
(* Les hooks de lancement apres le chargement d'un module *)
let start_hooks = ref []
@
% private? rename _start_hooks?

<<function Efuns.add_start_hook>>=
let add_start_hook hook = 
  start_hooks := hook :: !start_hooks
@


\section{The graphical window}

\subsection{[[Graphics.init()]]}

<<toplevel Main._4>>=
let _ =
  Graphics_X11.init location !displayname
@
%  Graphics.open_graph (spf " ");
%  Graphics.set_window_title displayname;
%  let display = "" in
%  ...
%  let top_window = Top_window.create location display in
%  ...
%  let _ = Interactive.create_bindings location in
%  ...
%  Top_window.update_display location;
%  ...
%  event loop
%    ...
%    Top_window.handler top_window () evt
%    ...


% will see main functions called from init below

\subsection{[[Top_window.create()]]}

<<function Top_window.create>>=
let create location display =
 
  <<[[Top_window.create()]] create graphical window with right dimensions>>

  let buf = 
    Ebuffer.default location "*help*" in
  let window = 
    Window.create_at_top  0 0 location.loc_width (location.loc_height - 1) in
  let frame = 
    Frame.create_without_top location window None buf in
  let top_window =
    { 
      top_name = "window";
      top_width = location.loc_width;
      top_height = location.loc_height;
      window = window;
      top_active_frame = frame;

      top_mini_buffers = [];
      top_second_cursor = None;

      top_display = Some display;
      top_xterm = Some ();

      top_location = location;
    } 
  in
  <<[[Top_window.create()]] optional scrollbar setup>>

  frame.frm_window.win_up <- TopWindow top_window;
  location.top_windows <- top_window :: location.top_windows;

  <<[[Top_window.create()]] create menus>>
  <<[[Top_window.create()]] misc stuff>>

  top_window
@
% loc_height -1 for the minibuffer.
% top_mini_buffers is empty at first, the minibuffer is created
% on the fly when do M-x, but before that it does not really
% exist (hmm what about Top_window.message() though?)

%(*
%      top_term = xterm;
%      top_attrs = Array.create 256 None;
%      top_root=  display.WX_xterm.root_oo;
%      top_appli = top;
%      top_scrollbar = ady;
%*)





<<function Ebuffer.default>>=
let default location name =
  try
    Hashtbl.find location.loc_buffers name
  with Not_found ->
      let str = 
        if name = "*help*" 
        then "Welcome to Efuns, a small demo editor written in Ocaml.

Fabrice Le Fessant
PARA/SOR Project
INRIA Rocquencourt
"
        else ""
      in
      create location name None (Text.create str) (Keymap.create ())
@

%(*
%"
%Version is " ^ Version.efuns_version ^"
%built by "^ Version.builder ^ " " ^ Version.date ^ " 
%with
%Efuns installation directory : " ^ Version.efuns_lib ^ "
%Ocaml installation directory : " ^ Version.ocamllib ^ "
%
%Fabrice Le Fessant
%PARA/SOR Project
%INRIA Rocquencourt
%
%Help for Key Bindings: C-h K
%See changes in "^ Version.efuns_lib ^"/Changes
%"
%*)


<<[[Top_window.create()]] create graphical window with right dimensions>>=
(*
let top = new WX_appli.t display.WX_xterm.root_oo [] in
top#setWM_NAME "new_frame";
top#setWM_CLASS "Efuns" "efuns";
let hbar = new WX_bar.h top#container [] in
top#container_add hbar#contained;
let xterm = new WX_xterm.t 
    hbar#container display
    location.loc_width
    location.loc_height in
let ady = new WX_adjust.t () in
let scrollbar = new WX_scrollbar.v hbar#container ady [] in
hbar#container_add_s [xterm#contained; scrollbar#contained];
*)
@

<<[[Top_window.create()]] misc stuff>>=
(* let xterm = xterm#xterm in *)
let xterm = () in
top_window.top_xterm <- Some xterm;

(*
  WX_xterm.install_handler display xterm (handler top_window xterm);
  top#configure [Bindings [Key (anyKey, anyModifier), (fun _ ->
          handler top_window xterm (WX_xterm.XTKeyPress (
              !WX_types.modifiers_event, !key_string, !key_sym));
          WX_xterm.update_displays ()
    )]];
*)
@

\subsection{[[Top_window.update_display()]]}

<<function Top_window.update_display>>=
let update_display location =
  location.top_windows |> List.iter (fun top_window ->
      top_window.window |> Window.iter (fun frm -> Frame.update top_window frm);
      (match top_window.top_mini_buffers with
       | [] -> ()
       | frame :: _ -> Frame.update top_window frame
      );
      cursor_on top_window;
  ) 
@
% why have a list of top_windows?
% Frame.update only the first minibuffer? then why use a list anyway?

% minibuffer is a frame!
% status line? it's attached to a frame actually

% will see Frame.update() later
% will see cursor_on() later

\section{The event loop}

%  let rec loop () =
%      let evt = ... in
%      ...
%      Top_window.handler top_window () evt
%  in
%  loop ()


\subsection{[[Top_window.handler()]]}

<<function Top_window.handler>>=
let handler top_window xterm event =
  let location = top_window.top_location in
  Mutex.lock location.loc_mutex;
  try
    begin
      match event with
      <<[[Top_window.handler()]] match event cases>>
    end;
    Mutex.unlock location.loc_mutex;
  with
    e ->   
      Mutex.unlock location.loc_mutex;
      raise e
@
%old: was using top_window.top_location.loc_mutex in 2 cases of 3
% more consistent to always use the same form
%less: could do with_lock () instead of this style



\subsection{[[Top_window.handle_key()]]}

<<[[Top_window.handler()]] match event cases>>=
|  WX_xterm.XTKeyPress (modifiers, _s, keysym) ->
      handle_key top_window modifiers keysym
@
%  (*
%    if (keysym < XK.xk_Shift_L || keysym > XK.xk_Hyper_R)
%    then 
%  *)


<<constant Top_window.keypressed>>=
let keypressed = ref 0
@
% who uses that?

<<constant Top_window.handle_key_start_hook>>=
let handle_key_start_hook = Local.create_abstr "handle_key_start_hook"
@

<<constant Top_window.handle_key_end_hook>>=
let handle_key_end_hook = Local.create_abstr "handle_key_end_hook"
@


<<function Top_window.handle_key>>=
let handle_key top_window modifiers keysym =
  keypressed := keysym;
  let location = top_window.top_location in
  let frame = top_window.top_active_frame in

  clean_display location;
  clear_message top_window;

  exec_hooks 
     (try get_global location handle_key_start_hook with _ -> []) location;

  let mod_ = 
    <<[[Top_window.handle_key()]] compute mod>>
  in
  let key = (mod_, keysym) in
  begin
    try
      (* should lead to an action being triggered and modifying things! *)
      try_map frame key
    with
    <<[[Top_window.handle_key()]] handle exception of try_map>>
  end;

  exec_hooks 
      (try get_global location handle_key_end_hook with _ -> []) location;

  update_display top_window.top_location
@
% update_display again!
% will see try_map() later in keyboard section


<<[[Top_window.handle_key()]] compute mod>>=
let mask = Xtypes.controlMask lor !meta in
let diff = modifiers land mask in
match () with
| _ when diff = Xtypes.controlMask -> ControlMap
| _ when diff = !meta -> MetaMap
| _ when diff = 0 -> NormalMap 
| _ -> ControlMetaMap
@



% so for now remains Frame.update, and Top_window.try_map
% which are essential to understand.

\chapter{Text Managment}

%Text.representation text line --> string (buffer or copy) * int (position)
%Text.items line -> item array

%module Text = struct
%    type t = text
%    type text = t
%    type l = line
%    type line = l
%      
%    let representation tree line = line.repr_string, line.position
%    let items tree line = line.items
%  end

\section{Gap buffer}

%from guide.txt:
%The Text.t type implements a gap-buffer. A gap-buffer is a buffer with
%a big hole inside. Why ? To insert one char inside a buffer, you need to move
%all the end of the buffer by one char before inserting. This is too expensive
%for very large buffers. Instead, gap-buffers have a hole. To insert one char
%in the buffer, you only need to move the hole to your position, and to insert
%the char at the first position of the hole. Then, to insert a second char
%just after the first one (the most used operation in an editor), you only
%need to put it at the new first position of the hole.
%
%                       v
%aaaaaaaaaaa-------aaaaaaaaaaaaaaaaaa
%
%=> move the hole
%                       v
%aaaaaaaaaaaaaaaaaaaaaaa-------aaaaaa
%
%=> insert your char
%                       v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> move the cursor
%                        v
%aaaaaaaaaaaaaaaaaaaaaaab------aaaaaa
%
%=> insert the second char without moving any chars :)
%
%                        v
%aaaaaaaaaaaaaaaaaaaaaaabc-----aaaaaa
%
%Inside the Text.t structure, cursors are represented by Text.point structures.
%Indeed, when the gap (the hole) moves inside the buffer, all cursors must
%be updated with the new offset of the gap. This might be expensive, however,
%thanks to Ocaml modules, other Text implementations could be tested without
%breaking the editor.

%http://en.wikipedia.org/wiki/Gap_buffer
%http://scienceblogs.com/goodmath/2009/02/18/gap-buffers-or-why-bother-with-1/

%alternative used in emacs:
%http://en.wikipedia.org/wiki/Rope_(data_structure)


\section{Text representation}

% do we need something fancy? naive brute force too slow?


<<type Text.line>>=
and line = {
    mutable position : direct;

    mutable representation : repr list;
    mutable repr_len : int;
    mutable repr_string : string;

    (* hightlighting on the line:
    0 => no hightlighting
    n => chars are hightlighted from the beginning of the line until pos n
    *)
    mutable items : item array;

    <<[[Text.line]] other fields>>
  } 
@

%XXX
<<[[Text.line]] other fields>>=
mutable modified : int; (* first modified position *)
mutable line_hlt : int;
@




%(* from WX_text *)
<<type Text.item>>=
type item =
  String     of item_attr list * int
| RealString of item_attr list * string
@
%(*| Widget of contained array*)

<<type Text.item_attr>>=
and item_attr =
  Font of font
| Foreground of color
| Background of color
@




%XXX?
<<type Text.repr>>=
and repr = 
  { 
    repr_line_pos : int;   (* pos of repr in Text.t string *)
    repr_line_len : int;   (* len of repr in Text.t string *)
    
    mutable repr_attr : int;    (* common attribute *)
    repr_charsize : int; (* common size *)
    
    repr_size : int;
    repr_pos : int;  (* pos of repr in representation string *)
  } 
@

% Line.position type
<<type Text.direct>>=
type direct = int
@


% why not use this type in Text.text.attrs? int array -> attribute array?
<<type Text.attribute>>=
type attribute = int
@

<<type Text.delta>>=
type delta = int
@

<<type Text.position>>=
type position = int
@
% used?


<<type Text.session>>=
type session = int
@
% used?




%XXX?
<<type Efuns.line_repr>>=
and line_repr =
  { 
    mutable repr_line : Text.line;
    mutable repr_y : int;
    mutable repr_x : int;

    mutable repr_prev_offset : int;
    mutable repr_prev_reprs : Text.repr list;
    mutable repr_offset : int;
    mutable repr_reprs : Text.repr list;
  } 
@
% Frame.frm_table??





\section{Points}

<<[[Text.text]] other fields>>=
mutable text_points : point list;
@

% there are list of points maintained by the Text itself, why?
% because of gap things can move so you need to update all
% the points? So need to create point by using specific
% API that update this list of points


<<function Text.add_point>>=
let add_point tree =
  let text = tree.tree_text in      
  let p = {
      point = 0;
      point_y = 0;
    } in    
  text.text_points <- p :: text.text_points;
  p
@

<<function Text.dup_point>>=
let dup_point tree point =
  let text = tree.tree_text in      
  let p = {
      point = point.point;
      point_y = point.point_y
    } in
  text.text_points <- p :: text.text_points;
  p
@

<<function Text.remove_point>>=
let remove_point tree p =
  let text = tree.tree_text in      
  text.text_points <- 
    text.text_points |> List.fold_left (fun points point ->
        if point == p then points else point :: points) 
    []
@






<<function Text.goto_point>>=
let goto_point text p1 p2 =
  p1.point <- p2.point;
  p1.point_y <- p2.point_y
@


\section{The gap}

%    let gap_end = gpoint + text.text_gsize in

<<[[Text.text]] other fields>>=
(* g for gap *)
mutable text_gpoint : int;
mutable text_gline : int;
mutable text_gsize : int;
@
% rename gpoint? it's not really a point, or rename
% gline to gpoint_y? more consistent?
% gx, gy, gsize gap col, gap line, gap size


<<function Text.size>>=
let size tree = 
  let text = tree.tree_text in
  text.text_size - text.text_gsize
@
% gsize is 0 at the very beginning

<<function Text.move_point_to>>=
let move_point_to tree point p =
  let text = tree.tree_text in    
  let _x,y = find_xy tree text.text_gpoint text.text_gline p in
  point.point <- p;
  point.point_y <- y
@


\section{Text attributes}

<<[[Text.text]] other fields>>=
mutable text_attrs : int array;
@
% int, because need to be efficient!
% attribute is an encoded int, direct_attr = black fg, white bg, no highlight
% regular font. Want efficient representation here because each
% character will have this attribute?

<<function Text.make_attr>>=
let make_attr fg bg font highlighted =
  let attr = fg + (bg lsl 8) + (font lsl 16) + 
      (if highlighted then 1 lsl 24 else 0) 
  in
  attr
@
% 8 bits fg, 8 bigs bg, 8 bits font, 1 bit highlight
% color map = 0 -> black, 1 -> white?

<<constant Text.direct_attr>>=
let direct_attr =  make_attr 0 1 0 false
@

<<constant Text.inverse_attr>>=
let inverse_attr =  make_attr 1 0 0 false
@

% let no_attr = 0?

<<function Text.unset_attr>>=
let unset_attr text =
  let text = text.tree_text in  
  Array.fill text.text_attrs 0 (Array.length text.text_attrs) direct_attr;
  Array.iter (fun line -> line.modified <- 0) text.text_newlines
@

<<function Text.set_attr>>=
let set_attr tree point len attr = (* should not exceed one line *)
  let text = tree.tree_text in  
  if len > 0 then
    let gap_end = text.text_gpoint + text.text_gsize in
    let x,y = find_xy tree text.text_gpoint text.text_gline point.point in
    cancel_repr text point.point y;
    let point = point.point in
    let gpoint = text.text_gpoint in
    let before, after, after_pos =
      if point > gap_end then
        0, (min (text.text_size - point) len), point
      else
      if point + len <= gpoint then
        0, len, point
      else
      let before = gpoint - point in
      let after = min (len - before) (text.text_size - gap_end) in
      before, after, gap_end
    in
    let attrs = text.text_attrs in
    if before > 0 
    then Array.fill attrs point before attr;
    Array.fill attrs after_pos after attr
@


<<function Text.get_attr>>=
let get_attr tree point =
  let text = tree.tree_text in
  let point = 
    if point.point = text.text_gpoint 
    then point.point + text.text_gsize 
    else point.point
  in
  if point < text.text_size then
    text.text_attrs.(point)
  else
    direct_attr
@

<<function Text.set_char_attr>>=
let set_char_attr tree point attr =
  let text = tree.tree_text in    
  let y = point.point_y in
  let point = 
    if point.point = text.text_gpoint 
    then point.point + text.text_gsize 
    else point.point
  in
  if point < text.text_size then begin
    cancel_repr text point y;
    text.text_attrs.(point) <- attr
  end
@


\section{Colors}

<<[[Efuns.location]] other fields>>=
loc_colors : (string,int) Hashtbl.t;
loc_colors_names : string array;
mutable loc_colors_n : int;
@
% 0 1 are used!
% can seem limited to have a color map, but to have
% an efficient representation for text attributes, it's
% better to use an int which then index in different maps (color map,
% font map)

% have side effect of setting the color if it's not there before!
<<function Window.get_color>>=
let get_color location color_name =
  try
    Hashtbl.find location.loc_colors color_name
  with
    Not_found ->
      if location.loc_colors_n = 256 then
        raise Not_found
      else
        let n = location.loc_colors_n in
        location.loc_colors_n <- n + 1;
        location.loc_colors_names.(n) <- color_name;
        Hashtbl.add location.loc_colors color_name n;
        n
@


<<constant Main.highlight_color>>=
let highlight_color = define_option ["highlight_color"] "" color_option "cyan"
@

<<toplevel Main._2>>=
let _ =
(* color 0 is foreground *)
  let _ = Window.get_color location !!foreground in
(* color 1 is background *)
  let _ = Window.get_color location !!background in
(* color 2 is highlight *)
  let _ = Window.get_color location !!highlight_color in
@


\section{Fonts}
% with an 's'?

<<[[Efuns.location]] other fields>>=
loc_fonts : (string,int) Hashtbl.t;
loc_fonts_names : string array;
mutable loc_fonts_n : int;
@

% similar to get_color, have the side effect of "allocating" a new font
<<function Window.get_font>>=
let get_font location font_name =
  try
    Hashtbl.find location.loc_fonts font_name
  with
    Not_found ->
      if location.loc_fonts_n = 256 then
        raise Not_found
      else
        let n = location.loc_fonts_n in
        location.loc_fonts_n <- n + 1;
        location.loc_fonts_names.(n) <- font_name;
        Hashtbl.add location.loc_fonts font_name n;
        n
@

<<toplevel Main._2>>=
(* font 0 is initial font *)
  Window.get_font location !!font
@



\chapter{Main Window}

% menu
% windows/frames with buffers
% status line (for each frame get this actually)
% minibuffer (a single one)


% see graphics_graphics.ml

\section{Menus}

<<toplevel Std_efunsrc._4>>=
let _ =
  <<[[Std_efunsrc]] file menu setup>>
  <<[[Std_efunsrc]] edit menu setup>>
  <<[[Std_efunsrc]] help menu setup>>
  <<[[Std_efunsrc]] buffers menu setup>>
@




<<[[Top_window.create()]] create menus>>=
(*
  top#add_button "Buffers" (!buffers_menu top_window);
  top#add_menu "File" (Array.map (fun (name,action) ->
        wrap_item top_window (name, execute_action action)
    ) (Array.of_list !!file_menu));
  top#add_menu "Edit" (Array.map (fun (name,action) ->
        wrap_item top_window (name, execute_action action)
    ) (Array.of_list !!edit_menu));
  List.iter (fun (menu_name, items) ->
      top#add_menu menu_name 
        (Array.map (fun (name,action) ->
            wrap_item top_window (name, execute_action action)
        ) (Array.of_list items))
  ) !!menus;
  top#add_separator;
  top#add_menu "Help" (Array.map (wrap_item top_window) !help_menu);
  top#show;
*)
@


\subsection{File menu}

<<constant Top_window.file_menu>>=
let file_menu = define_option ["file_menu"] "" (list_option string2_option) []
@

<<[[Std_efunsrc]] file menu setup>>=
if !!file_menu = [] then begin
    file_menu =:=    [
      "Open File", "select_open_file";
      "Save Buffer", "save_buffer";
      <<file menu entries>>
      "", "";
      "Quit", "exit";
    ]
  end;
@
% cool, everything is configurable :)

\subsubsection{Opening a file}

%less: optional I think, this use the toolkit to offer a file
% browser, but could redirect instead to "load_buffer" which
% use the minibuffer to open a file
<<loading actions>>=
define_action "select_open_file" select_open_file;
@

<<function Std_efunsrc.select_open_file>>=
let select_open_file frame =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let cdir = Frame.current_dir frame in
  failwith "Std_efunsrc.select_open_file: TODO"
(*
  let info = {
      filter = Filename.concat cdir "*";
      current_selection = cdir;
      predicat = (fun _ -> true);
      action = (fun _ -> ());
      cancel = (fun _ -> ());
    } in

  (* X11 *)
  let query = new WX_filesel.t top_window.top_root info [] in
  query#setWM_TRANSIENT_FOR (top_window.top_appli#top :> WX_types.container);
  info.action <- (fun name ->
      wrap top_window (fun top_window ->
          query#destroy;
          let _ = Frame.load_file window name in ()
      ) ());
  info.cancel <- (fun () ->
      wrap top_window (fun top_window ->
          query#destroy;
      ) ());        
  query#show
*)
@





% C-x C-f!

<<loading keys>>=
[c_x; ControlMap, Char.code 'f'], "load_buffer";
@
<<loading actions>>=
(* C-x map *)
define_action "load_buffer"  load_buffer;
@


% in Complex because requires select and minibuffer
<<function Complex.load_buffer>>=
let load_buffer frame = 
  set_previous_frame frame;
  select_filename frame "Find file: " (fun str -> 
      let _ = Frame.load_file frame.frm_window str in ())
@
% see later select_filename, quite complicated, use minibuffer
% and completion buffer.

%\subsection{Helpers}

<<function Frame.load_file>>=
let load_file window filename =
  let top_window = Window.top window in
  let location = top_window.top_location in

  let buf = Ebuffer.read location filename (Keymap.create ()) in
  let frame = create window None buf in
  exec_named_hooks !!change_buffer_hooks frame;
  status_name frame buf.buf_name;
  frame
@





<<loading keys>>=
[c_x; NormalMap, Char.code 'i'], "insert_file";
@
<<loading actions>>=
(* C-x map *)
define_action "insert_file"  insert_file;
@

<<function Complex.insert_file>>=
let insert_file frame =
  select_filename frame "Insert file: " (fun str ->
      let inc = open_in str in
      insert_string frame (Utils.read_string inc);
      close_in inc
  )
@



\subsubsection{Saving the buffer}

<<saving keys>>=
[c_x; ControlMap, Char.code 's'], "save_buffer"; 
@
<<saving actions>>=
(* C-x map *)
define_action "save_buffer"  save_buffer; 
@

<<function Complex.save_buffer>>=
let save_buffer frame =
  let buf = frame.frm_buffer in
  match buf.buf_filename with
    Some _ -> Ebuffer.save buf
  | None -> write_buffer frame
@


<<[[Efuns.buffer]] other fields>>=
mutable buf_last_saved : int;
@

<<function Ebuffer.save>>=
let save buf =
  exec_named_buf_hooks_with_abort !!saved_buffer_hooks buf;

  let filename =
    match buf.buf_filename with
      None -> raise Not_found
    | Some name -> name
  in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  buf.buf_last_saved <- version buf.buf_text;

  exec_named_buf_hooks !!saved_buffer_hooks buf
@


%\subsubsection{Hooks}
% see also in core DS chapter
% - create_buf_hook  (check_file)
% - change_buffer_hooks
% - save_buffer_hooks (dead??)
% - saved_buffer_hooks


<<constant Ebuffer.saved_buffer_hooks>>=
let saved_buffer_hooks = define_option ["saved_buffer_hooks"] "" 
    (list_option string_option)
  ["update_time" ]
@

<<misc actions>>=
define_buffer_action "update_time" update_time;
@



<<saving keys>>=
[c_x; NormalMap, Char.code 's'], "save_some_buffers";
[c_x;ControlMap, Char.code 'w'], "write_file"; 
@
<<saving actions>>=
(* C-x map *)
define_action "save_some_buffers"  save_some_buffers;
(* C-x map *)
define_action "write_file"  write_buffer; 
@


<<function Complex.save_some_buffers>>=
let save_some_buffers frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buffers = list_of_hash location.loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> ())
@
%less: save_buffers_and_action here?

<<function Complex.write_buffer>>=
let write_buffer frame = 
  let buf = frame.frm_buffer in
  select_filename frame "Save file as: " (fun str -> 
      let top_window = Window.top frame.frm_window in
      Ebuffer.change_name top_window.top_location buf str;
      Ebuffer.save buf
  )
@

%\subsection{Helpers}
<<function Frame.save_buffer>>=
let save_buffer frame =
  Ebuffer.save frame.frm_buffer
@
% dead?




\subsubsection{Exit}

<<misc keys>>=
[c_x; ControlMap, Char.code 'c'], "exit"; 
@

<<misc actions>>=
(* C-x map *)
define_action "exit"  exit_efuns; 
@

<<function Complex.exit_efuns>>=
let exit_efuns frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buffers = Utils.list_of_hash location.loc_buffers in
  save_buffers_and_action frame buffers (fun _ -> 
    (* todo: have some exit hooks? *)
    Graphics.close_graph ();
    exit 0
  )
@

%todo: save_buffers_and_action?

\subsection{Edit menu}

<<constant Top_window.edit_menu>>=
let edit_menu = define_option ["edit_menu"] ""
    (list_option string2_option) []
@

<<[[Std_efunsrc]] edit menu setup>>=
if !!edit_menu = [] then begin
    edit_menu =:= [ 
      "Cut",    "kill_region";
      "Paste",  "insert_killed";

      "Undo",    "undo";
      "", "";
      <<[[edit_menu]] entries>>
    ];
  end;
@
% will see later

\subsection{Buffers menu}

% will see later

\subsection{Help menu}

<<constant Top_window.help_menu>>=
let help_menu = ref ([| |]: (string * (frame -> unit)) array)
@
% this one is not configurable apparently

<<[[Std_efunsrc]] help menu setup>>=
help_menu := [|
  "Key Bindings", (fun frame ->
      Frame.change_buffer frame.frm_window "*bindings*"
  );
  "About Efuns", (fun frame ->
    Frame.change_buffer frame.frm_window "*help*"
  );
  "Changes", (fun frame ->
    (*
      let _ = Frame.load_file frame.frm_window (
          Version.efuns_lib ^"/Changes") in ()
    *)
    failwith "Std_xxx.menu changes: TODO"
  );

|];
@
% see Frame.change_buffer later

%   (*
%        let top_window = Window.top frame.frm_window in        
%        let dialog = new WX_dialog.t top_window.top_root 
%            "Efuns,\nVersion 015\nFabrice Le Fessant\nFabrice.Le_Fessant@inria.fr" [] in
%        dialog#add_button "OK" (fun _ -> dialog#destroy);
%        dialog#show;
%    *)




\section{Sub-windows/Frames}

% the redisplay function!!!

<<[[Efuns.frame]] other fields>>=
(* first point of the first buffer-line on screen *)
mutable frm_start : Text.point;
(* last point on screen, -1 if modified *)
mutable frm_end : Text.point;
(* offset(+/-) of screen-lines after frm_start *)
mutable frm_y_offset : int;
@




<<[[Efuns.frame]] other fields>>=
mutable frm_mini_buffer : string option;
@

<<[[Efuns.frame]] other fields>>=
(* 0 for no scrollbar, 2 for scrollbar *)
mutable frm_has_scrollbar : int;
(* 0 for minibuffer, 1 for normal frame *)
mutable frm_has_status_line : int;
@


<<[[Efuns.frame]] other fields>>=
mutable frm_last_text_updated : int;
mutable frm_last_buf_updated : int;
@
% diff?


<<[[Efuns.frame]] other fields>>=
mutable frm_force_start : bool;
mutable frm_x_offset : int;
mutable frm_cutline : int; (* max_int for no, else length *)
mutable frm_table : line_repr array;
mutable frm_redraw : bool;    
@


\subsection{[[Frame.update()]]}


% (main -> Graphics.init | event loop -> ...) -> Top_window.update_display -> <>
<<function Frame.update>>=
let update top_window frame =
  let buf =  frame.frm_buffer in
  let text = buf.buf_text in

  let start = frame.frm_start in
  let point = frame.frm_point in

  let width = frame.frm_width - frame.frm_has_scrollbar in
  let height = frame.frm_height - frame.frm_has_status_line in

  if  buf.buf_sync && buf.buf_modified <> frame.frm_last_buf_updated then
    Text.set_position text point (Text.size text); 
  if
    (frame.frm_end < point)  || 
    (start > point) ||
    (version text <> frame.frm_last_text_updated) ||
    (buf.buf_modified <> frame.frm_last_buf_updated) ||
    frame.frm_redraw
  then
    begin
      let start_c = point_to_cursor buf start in
      if start_c > 0 then
        begin
          frame.frm_y_offset <- 
            frame.frm_y_offset - start_c / frame.frm_cutline;
          let _ = Text.bmove text start start_c in
          ()
        end;
      let point_c = point_to_cursor buf point in
      if point_c < frame.frm_x_offset then
        begin
          frame.frm_x_offset <- max (point_c - width / 2) 0;
          frame.frm_redraw <- true;
        end
      else
      if frame.frm_cutline = max_int && 
        (point_c mod frame.frm_cutline >= frame.frm_x_offset + width - 3)  
      then
        begin
          frame.frm_x_offset <- point_c - (width / 2);
          frame.frm_redraw <- true;
        end;

      update_table top_window frame;

      begin
        if (frame.frm_end < point)  || (start > point)
        then
          begin
            if frame.frm_force_start then
              let x,y = 
                cursor_to_point frame frame.frm_cursor_x frame.frm_cursor_y
              in
              goto_line text frame.frm_point y;
              let _ = Text.fmove text frame.frm_point x in
              ()
            else
              begin
                goto_point text start point;
                frame.frm_y_offset <- - height / 2;
                let start_c = point_to_cursor buf start in
                if start_c > 0 then
                  begin
                    frame.frm_y_offset <- 
                      frame.frm_y_offset - start_c / frame.frm_cutline;
                    let _ = Text.bmove text start start_c in
                    ()
                  end;
                update_table top_window frame;
              end;
          end
      end;
      if frame == top_window.top_active_frame then
        begin
          frame.frm_force_start <- true; (* AVOID CYCLING IN SCROLLBAR *)
          let pos_start = get_position text frame.frm_start in
          let pos_end = get_position text frame.frm_end in

          Common.pr2_once "Frame.update: TODO scrollbar";
          (*top_window.top_scrollbar#set_params pos_start (pos_end - pos_start) 

             (size text);
          *)
        end;
      frame.frm_last_text_updated <- version text;
      frame.frm_last_buf_updated <- buf.buf_modified;
      frame.frm_force_start <- false;
      for y = 0 to height - 1 do
        let line = frame.frm_table.(y) in
        if not ((line.repr_prev_reprs == line.repr_reprs) &&
            (line.repr_prev_offset == line.repr_offset)) 
          || frame.frm_redraw
        then
          begin
            line.repr_prev_reprs <- line.repr_reprs;
            line.repr_prev_offset <- line.repr_offset;
            update_line top_window frame line.repr_line.repr_string y;
          end;
      done;
      frame.frm_redraw <- false
    end;
  let xterm = match top_window.top_xterm with
      None -> raise Not_found
    | Some xterm -> xterm 
  in
  match frame.frm_mini_buffer with
    None -> 
      let status = frame.frm_status in
      status_line frame (point_line text frame.frm_point);
      status_col frame  (point_col text frame.frm_point);
      status_modified frame (version text <> buf.buf_last_saved);
      status_name frame buf.buf_name;
      status_major_mode frame;
      if status.status_modified then

        WX_xterm.draw_string xterm
          frame.frm_xpos
          (frame.frm_ypos + frame.frm_height - 1)  
          status.status_string 0 width Text.inverse_attr
  | Some request ->
        WX_xterm.draw_string xterm
         0 (top_window.top_height-1)  
         request 0 (String.length request) Text.direct_attr
@

\subsection{Cursor}

% an output, but strongly related
% also to input devices (input device feedback essentially)



% Top_window.update_display -> <>
<<function Top_window.cursor_on>>=
let cursor_on top_window =
  let frame = top_window.top_active_frame in
  let name = frame.frm_buffer.buf_name in
  if not (name == top_window.top_name) then
    begin
      Common.pr2_once "Top_window.top_apply#setWM_NAME";
      (* top_window.top_appli#setWM_NAME name; *)
      top_window.top_name <- name
    end;
  set_cursor_on top_window frame;
  match top_window.top_second_cursor with
    None -> ()
  | Some frame -> set_cursor_on top_window frame
@


\subsection{Scrollbar}

<<[[Top_window.create()]] optional scrollbar setup>>=
(* ady#add_subject (fun () -> *) (
(*
      let ady = () in
      let frame = top_window.top_active_frame in
      if not frame.frm_force_start then
        wrap top_window (scroll_to_frame ady) ()
*)
  ()
  );
@


\subsection{[[Top_window.clean_display()]]}

% event loop -> ... -> handle_key -> ...; <>; Top_window.update_display()
<<function Top_window.clean_display>>=
let clean_display location =
  location.top_windows |> List.iter (fun top_window -> cursor_off top_window) 
@


\section{[[Status]] Line}

<<[[Efuns.frame]] other fields>>=
mutable frm_status : status;    
@

<<type Efuns.status>>=
and status =
  { 
    mutable stat_name : string;
    mutable stat_file : string;
    mutable stat_line : int;
    mutable stat_col : int;

    mutable status_modified : bool;
    mutable stat_modified : bool;
    <<[[Efuns.status]] other fields>>
  }
@


<<[[Efuns.status]] other fields>>=
mutable status_format : (status_info * (int * int)) list;
@

<<type Efuns.status_info>>=
and status_info =
| StatName
| StatFile
| StatLine
| StatCol
| StatModified
| StatMode
@
% also clock, load, etc

<<constant Frame.status_format>>=
let status_format = ref [
    StatModified , (1, 2);
    StatName, (5, 20);
    StatMode, (30,30);
    StatLine, (65, 5);
    StatCol, (70 , 5);
    StatFile, (35,15);
  ]
@
% meaning?

<<[[Frame.create_without_top()]] let status>>=
let status = {
    stat_name = "";
    stat_file = "";
    stat_col = -1;
    stat_line = -1;
    status_modified = true;
    stat_modified = (buf.buf_last_saved = version buf.buf_text);
    stat_modes = [];
    stat_mode = dummy_mode;

    status_format = !status_format;
    status_string = String.make 256 '-';
  } in
String.blit editname 0 status.status_string 5 (String.length editname);
@

<<constant Frame.editname>>=
let editname = "Efuns:"
@

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_name frame buf.buf_name;
@


<<function Frame.status_name>>=
let status_name frame name =
  let status = frame.frm_status in
  if status.stat_name <> name then
    begin
      status.stat_name <- name;
      status_print status name StatName
    end
@



% status_name | status_modified | ... -> <>
<<function Frame.status_print>>=
let status_print status str stat_type =
  status.status_modified <- true;
  try
    let (pos,maxlen) = List.assoc stat_type status.status_format in
    let len = min (String.length str) maxlen in
    String.blit str 0 status.status_string pos len;
    String.fill status.status_string (pos + len) (maxlen - len) ' '
  with
    Not_found -> ()
@

<<[[Efuns.status]] other fields>>=
(* the string! --- ... --- *)
mutable status_string : string;
@
% this will then be the only thing used in the rendering


% ?? -> <>
<<function Frame.status_modified>>=
let status_modified frame modified =
  let status = frame.frm_status in
  if status.stat_modified <> modified then
    begin
      status_print status (if modified then "**" else "--") StatModified;
      status.stat_modified <- modified
    end
@

% ?? -> <>
<<function Frame.status_col>>=
let status_col frame col =
  let status = frame.frm_status in
  if status.stat_col <> col then
    begin
      status.stat_col <- col;
      status_print status (Printf.sprintf "C%d" (col+1)) StatCol
    end
@

% Frame.update -> <>
<<function Frame.status_line>>=
let status_line frame line =
  let status = frame.frm_status in
  if status.stat_line <> line then
    begin
      status.stat_line <- line;
      status_print status (Printf.sprintf "L%d" (line+1)) StatLine
    end
@

% ?? -> <>
<<function Frame.status_file>>=
let status_file frame name =
  let status = frame.frm_status in
  if status.stat_file <> name then
    begin
      status.stat_file <- name;
      status_print status name StatFile
    end
@
% dead?



\section{Minibuffer}

\subsection{Minubuffer creation}

% when it's created? each type enter M-x?

<<[[Efuns.top_window]] other fields>>=
mutable top_mini_buffers : frame list;
@
% there are many mini_buffers??

% ?? -> <>
<<function Minibuffer.create>>=
let create frame local_map request =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let location = top_window.top_location in

  let mini_text = Text.create "" in
  let qlen = String.length request in
  let request = if qlen < 50 then request else
      (String.sub request 0 47 ^ "...") in

  let mini_buf = buf_create location mini_text local_map in

  let mini_window = Window.create true (*mini*) (TopWindow top_window) 
    qlen (top_window.top_height - 1)
    (top_window.top_width - qlen) 1 in
  let mini_frame = Frame.create mini_window (Some request) mini_buf
  in    
  mini_frame.frm_cutline <- max_int;
  mini_frame.frm_has_status_line <- 0;
  top_window.top_mini_buffers <- mini_frame :: top_window.top_mini_buffers;

  Keymap.add_binding local_map [ControlMap, Char.code 'g']
    (fun mini_frame -> kill mini_frame frame);
  mini_frame
@



<<[[Efuns.window]] other fields>>=
mutable win_mini : bool;
@


% ?? -> <>
<<function Minibuffer.buf_create>>=
let buf_create location text local_map =
  let buf =
    { 
      buf_text = text;
      buf_name = "*Minibuffer*";
      buf_filename = None; (* no connected file! *)

      buf_major_mode = fondamental_mode;
      buf_minor_modes = [];
      buf_syntax_table = Ebuffer.default_syntax_table;

      buf_modified = 0;
      buf_last_saved = version text;
      buf_history = [];
      buf_charreprs = charreprs;
      buf_map = local_map;
      buf_map_partial = true;
      buf_point = Text.add_point text;
      buf_sync = false;
      buf_mark = None;
      buf_start = Text.add_point text;
      buf_shared = 0;
      buf_finalizers = [];

      buf_vars = Local.vars ();
      buf_location = location;
    } in
  buf
@

<<constant Minibuffer.charreprs>>=
let charreprs = Array.init 256 (fun i ->   String.make 1 (Char.chr i))
@
<<toplevel Minibuffer._1>>=
let _ =
  charreprs.(9) <- String.make !tab_size ' '
@



\subsection{[[M-x foo]], [[call_interactive()]]}

<<meta keys>>=
[MetaMap, Char.code 'x'], "call_interactive";
@
<<meta actions>>=
define_action "call_interactive"  call_interactive;
@


<<constant Interactive.meta_hist>>=
let meta_hist = ref []
@

<<function Interactive.call_interactive>>=
let call_interactive frame =
  let buf = frame.frm_buffer in
  let interactives = buf_interactives buf in
  select frame "M-x " meta_hist "" 
    (fun _ -> List.map fst interactives)
    (fun s -> s) 
    (exec_interactive interactives frame)
@

<<function Interactive.buf_interactives>>=
let buf_interactives buf =
  let interactives = 
    buf.buf_major_mode.maj_map.interactives @
    buf.buf_location.loc_map.interactives 
  in
  List.fold_left (fun list minor -> minor.min_map.interactives @ list) 
   interactives buf.buf_minor_modes 
@


\subsection{Adding interactive functions}

%subsubsection{[[Map.interactives]]}

% in addition to char_map and complex_binding

<<[[Efuns.map]] other fields>>=
mutable interactives : (string * (action * prefix option)) list;
@
% record key so useful so can display the list of bindings?

<<type Efuns.prefix>>=
and prefix = key list
@

%\subsection{[[interactives_map]]}

<<constant Std_efunsrc.interactives_map>>=
let interactives_map = define_option ["interactives_map"] ""
    (list_option string2_option) 
  []
@

<<[[Std_efunsrc.toplevel]] set interactives_map>>=
if !!interactives_map = [] then begin
    interactives_map =:= List.map (fun x -> x, x ) [
      <<[[interactives_map]] initial entries>>
    ]
  end    
@

<<[[interactives_map]] initial entries>>=
"save_options";
"load_library";
"get_position";
"open_display";
"unset_attr";
"start_server";
@      


<<[[Std_efunsrc.init_global_map()]] add interactives from interactives_map>>=
List.iter (fun (name, action) ->
    try
      add_interactive location.loc_map name (execute_action action)
    with e ->
        Log.printf "Error for action %s" action;
        Log.exn "%s\n" e;
) !!interactives_map;
@

<<function Keymap.add_interactive>>=
let add_interactive map name f =
    map.interactives <- (name, (f, None)) :: map.interactives
@

% so each global key and their associated func is accessible!
<<[[Keymap.interactive()]] add keylist and name to interactives list>>=
map.interactives <- (name, (f, Some keylist)) :: map.interactives;
@

\subsection{[[Top_window.message()]]}

% convenient to communicate info


<<function Top_window.message>>=
let message top_window msg =
  let xterm = Window.xterm top_window in
  let len = String.length msg in
  WX_xterm.draw_string xterm 0 (top_window.top_height - 1)
    msg 0 len Text.direct_attr;
  WX_xterm.clear_eol xterm len (top_window.top_height - 1)
    (top_window.top_width - len);
  match top_window.top_mini_buffers with
    [] -> (* No mini-buffer ... *) ()
  | mini_buffer :: _ -> (* one mini-buffer is active *)
      match top_window.top_display with
        None -> ()
      | Some display ->
          WX_xterm.update_displays ();
          (* let _ = Unix.select [] [] [] 0.2 in *)
          mini_buffer.frm_redraw <- true
@


% event loop -> ... -> Top_window.handle_key -> <>
<<function Top_window.clear_message>>=
let clear_message top_window =
  match top_window.top_mini_buffers with
    [] -> 
      let xterm = Window.xterm top_window in
      WX_xterm.clear_eol xterm 0 
        (top_window.top_height - 1) top_window.top_width; 
  | _ -> ()
@



\chapter{Input Managment}

\section{Keyboard}

\subsection{Keys to action, [[try_map()]]}

<<exception Efuns.UnboundKey>>=
exception UnboundKey
@

% Top_window.handle_key -> <>(top_window.top_active_frame, ...)
<<function Top_window.try_map>>=
let try_map frame key =
  let keylist = frame.frm_prefix @ [key] in
  match Ebuffer.get_binding frame.frm_buffer keylist with
  | Function f ->
      <<[[Top_window.try_map()]] set repeat action>>
      frame.frm_prefix <- [];
      (* dispatch the action *)
      f frame; 
      <<[[Top_window.try_map()]] set last action>>
  | Prefix map ->
      frame.frm_prefix <- keylist;
      let top_window = top frame.frm_window in
      message top_window (Keymap.print_key_list frame.frm_prefix);
  | Unbound -> raise UnboundKey
@
% prefix?


% Ebuffer.get_binding is essentially trying to find the right map
% (buffer map, major mode map, global map)

% Ebuffer.get_binding -> <>
<<function Keymap.get_binding>>=
let rec get_binding map keylist =
  match keylist with
    [] -> Unbound
  | [key] ->
        <<[[Keymap.get_binding()]] find key in map>>
  | key :: tail ->
      match
        <<[[Keymap.get_binding()]] find key in map>>
      with
      | Prefix map -> get_binding map tail
      | _ -> Unbound
@
% lookup


<<[[Keymap.get_binding()]] find key in map>>=
(match key with
  (NormalMap,key) when key >= 0 && key < 256 -> 
    map.char_map.(key)
| _ -> 
    try
      List.assoc key map.complex_bindings
    with
      Not_found -> Unbound
 )
@

<<[[Top_window.handle_key()]] handle exception of try_map>>=
| UnboundKey -> 
    message top_window
      (Printf.sprintf "Unbound key %s %s"
        (Keymap.print_key_list frame.frm_prefix)
      (Keymap.print_key key));
    frame.frm_prefix <- [];
| Failure str -> message top_window str
| e -> message top_window 
      (Printf.sprintf "Uncaught exception %s" (Utils.printexn e))
@


\subsection{Action to keys, [[add_binding()]]}

<<function Keymap.add_binding>>=
let rec add_binding map key_list binding =
  match key_list with
    [] -> failwith "ERROR add_complex_binding: empty key list"
  | [key] -> set_binding map key (Function binding)
  | key :: tail ->
      match
        match key with
          (NormalMap,key) when key >= 0 && key < 256 -> 
            map.char_map.(key)
        | _ -> 
            try
              List.assoc key map.complex_bindings
            with
              Not_found -> Unbound
      with
        Prefix map -> add_binding map tail binding
      | Unbound ->
          let newmap = create () in
          set_binding map key (Prefix newmap);
          add_binding newmap tail binding;
      | e -> 
          failwith "ERROR add_complex_binding: Unable to add prefix"
@


<<function Keymap.set_binding>>=
let set_binding map key binding =
  match key with
    (NormalMap,key) when key >= 0 && key < 256 -> 
      map.char_map.(key) <- binding
  | _ -> 
      map.complex_bindings <- (key,binding) :: map.complex_bindings
@


\subsection{Bindings display}

<<function Keymap.all_bindings>>=
let all_bindings location =
  let s = ref "Default bindings:" in
  List.iter (fun (name,(_,binding)) ->
      match binding with
        None -> ()
      | Some key_list ->
          s := Printf.sprintf "%s\n%s : %s" !s 
            (print_key_list (List.rev key_list)) name
  ) location.loc_map.interactives;
  !s
@


<<function Keymap.print_key>>=
let print_key (map,keysym) =
  let prefix =
    match map with
      NormalMap -> ""
    | ControlMap -> "C-"
    | MetaMap -> "M-"
    | ControlMetaMap -> "CM-"
  in
  let kname =
    try
      List.assoc keysym (*XK.*)keysym_to_name
    with
      Not_found -> "?"
  in
  prefix^kname
@

<<function Keymap.print_key_list>>=
let rec print_key_list key_list =
  match key_list with
    key :: tail ->
      Printf.sprintf "%s %s" (print_key key) (print_key_list tail)
  | _ -> ""
@




% ?? -> <>
<<function Keymap.print>>=
let print map =
  Printf.printf "MAP:\n";
  List.iter (fun (key, binding) ->
    (match binding with
      Prefix _ -> print_string "Prefix "; 
    | Function _ -> print_string "Function"
    | Unbound -> print_string "Unbound"
          );
    print_string (print_key key);
    print_newline ()
      ) map.complex_bindings
@




\section{Mouse}

<<constant Top_window.mouse_x>>=
let mouse_x = ref 0
@

<<constant Top_window.mouse_y>>=
let mouse_y = ref 0
@

<<[[Top_window.handler()]] match event cases>>=
| WX_xterm.XTButtonPress (modifiers,button,x,y) -> 
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Button_Dflt + button)
@




<<[[Std_efunsrc.init_global_map()]] mouse keys setup>>=
add_global_key location [NormalMap, XK.xk_Pointer_Button1]
  "set_active_frame" mouse_set_frame;
add_global_key location [NormalMap, XK.xk_Pointer_Button2]
  "insert_at_point" mouse_yank_at_click;
add_global_key location [NormalMap, XK.xk_Pointer_Button3]
  "mouse_save_then_kill" mouse_save_then_kill;
@

<<function Simple.mouse_set_frame>>=
let mouse_set_frame frame =
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  goto_point text mark point;
  ()
@

<<function Simple.mouse_yank_at_click>>=
let  mouse_yank_at_click frame =
failwith "Simple.mouse_yank_at_click: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let frame = mouse_set_active top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let xterm = Window.xterm top_window in
  let str = WX_xterm.get_cutbuffer xterm in
  let _ = Text.insert text point str in
  Text.fmove text point (String.length str)
*)
@

<<function Simple.mouse_save_then_kill>>=
let mouse_save_then_kill frame =
  failwith "Simple.mouse_save_then_kill: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let frame = Top_window.find_selected_frame top_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark = Ebuffer.get_mark buf point in
  let new_point = add_point text in
  Frame.move_point frame new_point !mouse_x !mouse_y;
  if point = new_point then
    begin
      remove_point text new_point;
      let (start,term) =
        if point < mark then (point,mark) else (mark,point) 
      in
      let _ = Text.delete text start (Text.distance text start term) in
      ()
    end
  else
  let xterm = Window.xterm top_window in
  goto_point text mark point;
  goto_point text point new_point;
  remove_point text new_point;
  let str = Text.region text mark point in
  kill_string str;
  WX_xterm.set_cutbuffer xterm str;
  highlight frame
*)
@



<<[[Top_window.handler()]] match event cases>>=
| WX_xterm.XTMouseMotion (modifiers,button,x,y) ->
    mouse_x := x;
    mouse_y := y;
    handle_key top_window modifiers (XK.xk_Pointer_Drag_Dflt + button)
@

<<[[Top_window.handler()]] match event cases>>=
| WX_xterm.XTResize (new_width, new_height) ->
    resize_window top_window.window 0 0 new_width (new_height - 1);
    List.iter
      (fun frame -> 
        let window = frame.frm_window in
        window.win_ypos <- new_height - 1;
        window.win_width <- new_width;
        Frame.install window frame) top_window.top_mini_buffers;
    top_window.top_width <- new_width;
    top_window.top_height <- new_height;
    clear_message top_window;
    update_display top_window.top_location
@          


\section{Interactive select}
% here?

\chapter{Basic Features}

\section{Navigating}

<<navigating keys>>=
[NormalMap, XK.xk_Left], "move_backward"; 
[NormalMap, XK.xk_Right], "move_forward"; 
[ControlMap, Char.code 'b'], "move_backward";
[ControlMap, Char.code 'f'], "move_forward";

[ControlMap, XK.xk_Left ], "backward_word";
[ControlMap, XK.xk_Right ], "forward_word";  
[MetaMap, XK.xk_Left ], "backward_word";
[MetaMap, XK.xk_Right ], "forward_word";

[ControlMap, Char.code 'a'], "beginning_of_line";
[ControlMap, Char.code 'e'], "end_of_line";

[NormalMap, XK.xk_Up], "backward-line"; 
[NormalMap, XK.xk_Down], "forward_line"; 

[ControlMap, XK.xk_Up], "backward_paragraph";
[ControlMap, XK.xk_Down], "forward_paragraph";  

[NormalMap, XK.xk_Prior], "backward_screen"; 
[NormalMap, XK.xk_Next], "forward_screen";

[ControlMap, XK.xk_Next], "end_of_file";
[ControlMap, XK.xk_Prior], "begin_of_file";

@

<<navigating actions>>=
define_action "move_backward"  (fun frame -> ignore (move_backward frame 1));
define_action "move_forward"   (fun frame -> ignore (move_forward frame 1));

define_action "backward_word"  (to_frame backward_word);
define_action "forward_word"  (to_frame forward_word);  

define_action "beginning_of_line"  beginning_of_line;
define_action "end_of_line"  end_of_line;

define_action "backward-line"  backward_line;
define_action "forward_line"  forward_line;  

define_action "backward_paragraph"  (to_frame backward_paragraph);
define_action "forward_paragraph"  (to_frame forward_paragraph);  

define_action "backward_screen"  backward_screen;
define_action "forward_screen"  forward_screen;

define_action "begin_of_file"  begin_of_file;
define_action "end_of_file"  end_of_file;

(* M-x *)
define_action "goto_char" goto_char;
define_action "goto_line" goto_line;
@

<<[[interactives_map]] initial entries>>=
"goto_char";
"goto_line";
@

\subsection{Characters}

<<function Simple.move_backward>>=
let move_backward frame delta =
  let text = frame.frm_buffer.buf_text in
  Text.bmove text frame.frm_point delta
@

<<function Simple.move_forward>>=
let move_forward frame delta =
  let text = frame.frm_buffer.buf_text in
  Text.fmove text frame.frm_point delta
@

\subsection{Words and the syntax table}

%\section{Syntax table}
% was in core DS but better here I think

<<[[Efuns.buffer]] other fields>>=
mutable buf_syntax_table : bool array;
@

<<function Ebuffer.create_syntax_table>>=
let create_syntax_table ()  =
  let table = Array.create 256 false 
  in  
  for i = Char.code 'a' to Char.code 'z' do
    table.(i) <- true;
  done;
  for i = Char.code 'A' to Char.code 'Z' do
    table.(i) <- true;
  done;
  for i = Char.code '0' to Char.code '9' do
    table.(i) <- true;
  done;
  table
@

<<constant Ebuffer.default_syntax_table>>=
let default_syntax_table = create_syntax_table ()
@





<<function Simple.backward_word>>=
let backward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax
@

<<function Simple.forward_word>>=
let forward_word buf point =
  let text = buf.buf_text in
  let syntax = buf.buf_syntax_table in
  in_next_word text point syntax;
  to_end_of_word text point syntax
@





\subsection{Lines}

<<function Simple.beginning_of_line>>=
let beginning_of_line frame =
  let _ = move_backward frame (begin_to_point frame) in ()
@

<<function Simple.end_of_line>>=
let end_of_line frame =
  let eol = point_to_end frame in
  let _ = move_forward frame eol in ()
@


<<function Simple.backward_line>>=
let backward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if point_line text point > 0 then
    let old_x = begin_to_point frame in
    beginning_of_line frame;
    let _ = move_backward frame 1 in
    beginning_of_line frame;
    let _ = move_forward  frame (min old_x (point_to_end frame)) in ()
@

<<function Simple.forward_line>>=
let forward_line frame =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  if point_line text point < nbre_lines text then
    if point_to_end frame = 0 then
      begin
        let _ = move_forward frame 1 in
        end_of_line frame; ()
      end
    else
    let old_x = begin_to_point frame in
    end_of_line frame;
    let _ = move_forward frame 1 in
    let _ = move_forward frame (min old_x (point_to_end frame)) in ()
@


\subsection{Paragraphs}

<<function Simple.backward_paragraph>>=
let backward_paragraph buf point =
  let text = buf.buf_text in
  while bmove_res text point 1 = 1 && 
    (let c = get_char text point
      in
      c = '\n' || c = ' ') 
  do () done;
  try
    let _ = Text.search_backward text (Str.regexp "\n *\n") point in
    fmove text point 1; ()
  with
    Not_found ->
      set_position text point 0
@

<<function Simple.forward_paragraph>>=
let forward_paragraph buf point =
  let text = buf.buf_text in
  while
    (let c = get_char text point
      in
      c = '\n' || c = ' ') 
    && fmove_res text point 1 = 1 do () done;
  try
    let _ = Text.search_forward text (Str.regexp "\n *\n") point in
    fmove text point 1; ()
  with
    Not_found -> 
      set_position text point (Text.size text)
@

\subsection{Screens}

<<function Simple.backward_screen>>=
let backward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset - frame.frm_height + 2
@

<<function Simple.forward_screen>>=
let forward_screen frame =
  frame.frm_force_start <- true;
  frame.frm_redraw <- true;
  frame.frm_y_offset <- frame.frm_y_offset + frame.frm_height - 2
@

\subsection{File}

<<function Simple.begin_of_file>>=
let begin_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point 0
@

<<function Simple.end_of_file>>=
let end_of_file frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  Text.set_position text frame.frm_point (Text.size text)
@


\subsection{Position}

<<function Complex.goto_char>>=
let goto_char frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  simple_select frame "goto-char:" 
    (fun name ->
      let char = int_of_string name in
      Text.set_position text point char)
@

<<function Complex.goto_line>>=
let goto_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  simple_select frame "goto-line:" 
    (fun name ->
      let line = int_of_string name in
      Text.goto_line text point (line - 1))
@



%\subsection{Helpers}

<<function Text.point_to_eol>>=
let point_to_eol tree point =
  let text = tree.tree_text in    
  low_distance text point.point 
    (text.text_newlines.(point.point_y + 1).position - 1)
@

<<function Text.point_to_bol>>=
let point_to_bol tree point =
  let text = tree.tree_text in    
  low_distance text 
    text.text_newlines.(point.point_y).position
    point.point
@

<<function Text.point_to_eof>>=
let point_to_eof tree point =
  let text = tree.tree_text in    
  low_distance text point.point text.text_size
@

<<function Text.point_to_bof>>=
let point_to_bof tree point =
  let text = tree.tree_text in    
  low_distance text 0 point.point
@




<<function Text.point_to_lof>>=
let point_to_lof text point n =
  if n > 0 then
    point_to_eof text point
  else
    point_to_bof text point
@

<<function Text.point_to_lol>>=
let point_to_lol text point n =
  if n > 0 then
    point_to_eol text point
  else
    point_to_bol text point
@

<<function Text.point_to_line>>=
let point_to_line tree point line =
  let text = tree.tree_text in    
  let pos = 
    if text.text_nlines <= line + 1 then text.text_size
    else
      text.text_newlines.(line).position
  in
  move_point_to tree point text.text_newlines.(line).position
@



<<function Text.goto_line>>=
let goto_line tree point y =
  let text = tree.tree_text in      
  if text.text_nlines - 1 <= y then  
    set_position tree point (size tree)
  else 
  let line = text.text_newlines.(y) in
  point.point <- line.position;
  point.point_y <- y
@

\section{Inserting}

<<inserting keys>>=
[NormalMap, XK.xk_Return], "insert_return"; 
@
<<inserting actions>>=
define_action "insert_return"  insert_return;
@

<<function Simple.insert_return>>=
let insert_return frame =
  insert_char frame '\n'
@


<<constant Simple.single_char>>=
let single_char = String.make 1 ' '
@

<<function Simple.insert_char>>=
let insert_char frame char =
  let text = frame.frm_buffer.buf_text in
  let point = frame.frm_point in
  single_char.[0] <- char;
  let _ = Text.insert text point single_char in
  let _ = Text.fmove text point 1 in () 
@

\section{Deleting}

<<deleting keys>>=
[NormalMap, XK.xk_BackSpace], "delete_before_point"; 
[ControlMap, Char.code 'd'], "delete_at_point";
[NormalMap, XK.xk_Delete], "delete_at_point"; 

[MetaMap, Char.code 'd' ], "delete_forward_word";
[MetaMap, XK.xk_BackSpace ], "delete_backward_word";

[ControlMap, XK.xk_BackSpace], "hungry_electric_delete";
[ControlMap, Char.code 'k'], "kill_end_of_line";
@

<<deleting actions>>=
define_action "delete_before_point"  delete_backspace_char;
define_action "delete_at_point"  delete_char;

define_action "delete_forward_word"  (to_frame delete_forward_word);
define_action "delete_backward_word"  (to_frame delete_backward_word);

define_action "hungry_electric_delete"  hungry_electric_delete;
define_action "kill_end_of_line"  kill_end_of_line;
@

\subsection{Characters}

<<function Simple.delete_backspace_char>>=
let delete_backspace_char frame =
  let text = frame.frm_buffer.buf_text in
  if Text.bmove_res text frame.frm_point 1 <> 0 then
    let _ = Text.delete text frame.frm_point 1 in
      ()
@

<<function Simple.delete_char>>=
let delete_char frame =
  let text = frame.frm_buffer.buf_text in
  let _ = Text.delete text frame.frm_point 1 in
  ()
@

\subsection{Words}

<<function Simple.delete_backward_word>>=
let delete_backward_word buf point =
  let text = buf.buf_text in
  let old_point = dup_point text point in
  backward_word buf point;
  let _ = Text.delete text point (Text.distance text point old_point) in
  remove_point text old_point;
  ()
@

<<function Simple.delete_forward_word>>=
let delete_forward_word buf point =
  let text = buf.buf_text in
  let old_point = dup_point text point in
  forward_word buf point;
  let len = Text.distance text old_point point in
  remove_point text old_point;
  Text.bmove text point len;
  let _ = Text.delete text point len in
  ()
@

\subsection{Lines}

<<function Simple.kill_end_of_line>>=
let kill_end_of_line frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let eol = point_to_end frame in
  let len = if eol = 0 then 1 else eol in
  kill_text text frame.frm_point len
@

%\subsection{XXX}

<<function Simple.hungry_char>>=
let hungry_char c = 
  c = ' ' || c = '\n' || c = '\t'
@

<<function Simple.hungry_electric_delete>>=
let hungry_electric_delete frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let session = start_session text in
  let c1 = previous_char frame in
  delete_backspace_char frame;
  let c2 = previous_char frame in
  begin
    if hungry_char c1 && hungry_char c2 then
      try
        delete_backspace_char frame;
        while 
          let c = previous_char frame in
          hungry_char c        
        do
          delete_backspace_char frame
        done;
        insert_char frame ' '
      with
        Not_found -> ()
  end;
  commit_session text session
@



\section{Moving}

<<moving keys>>=
[ControlMap, Char.code ' '], "mark_at_point";
[ControlMap, Char.code 'w'], "kill_region";
[ControlMap, Char.code 'y'], "insert_killed";
[MetaMap, Char.code 'y'], "insert_next_killed";
@

<<moving actions>>=
define_action "mark_at_point"  mark_at_point;
define_action "kill_region"  kill_region;
define_action "insert_killed"  insert_killed;
define_action "insert_next_killed"  insert_next_killed;
@

\subsection{Mark}

<<function Complex.mark_at_point>>=
let mark_at_point frame =
  let top_window = Window.top frame.frm_window in
  Ebuffer.set_mark frame.frm_buffer frame.frm_point;
  Top_window.message top_window "Mark set";
  ()
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_mark : Text.point option;
@

<<function Ebuffer.set_mark>>=
let set_mark buf point =
  let text = buf.buf_text in
  buf.buf_modified <- buf.buf_modified + 1;
  match buf.buf_mark with
    None ->
      let mark = dup_point text point in
      buf.buf_mark <- Some mark
  | Some mark ->
      goto_point text mark point
@




<<function Ebuffer.get_mark>>=
let rec get_mark buf point =
  match buf.buf_mark with
    None -> 
      set_mark buf point;
      get_mark buf point
  | Some mark -> mark
@

<<function Ebuffer.remove_mark>>=
let remove_mark buf =
  match buf.buf_mark with
    None -> ()
  | Some mark ->
      buf.buf_mark <- None;
      remove_point buf.buf_text mark;
      buf.buf_modified <- buf.buf_modified + 1
@

\subsection{Highlight}

\subsection{Cut}

<<function Simple.kill_region>>=
let kill_region frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let mark =
    match buf.buf_mark with
      None -> failwith "No mark set"
    | Some mark -> mark
  in
  let (start,term) = 
    if mark > point then (point,mark) else (mark,point)
  in
  let _,region = Text.delete_res text start (distance text start term) in
  kill_string region
@

\subsection{Copy}
% M-w?

\subsection{Paste}

<<constant Simple.kill_ring>>=
let kill_ring = Array.create kill_max ""
@

<<function Simple.insert_killed>>=
let insert_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let pos, len =  Text.insert_res text point kill_ring.(0) in
  fmove text point len; 
  last_insert := Some(frame,pos,0,len)
@

<<constant Simple.last_insert>>=
let last_insert = ref None
@

<<function Simple.insert_next_killed>>=
let insert_next_killed frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  match !last_insert with
  |  Some (oldframe,oldpoint,n,len) when 
    oldframe == frame && oldpoint + len = get_position text point ->
      let n = if n = (min !kill_size kill_max) - 1 then 0 else n+1 in
      bmove text point len;
      let _ = Text.delete text point len in
      let pos, len =  Text.insert_res text point kill_ring.(n) in
      fmove text point len;
      last_insert := Some(frame,pos,n,len)
  | _ -> ()
@

\section{Undo}

<<undoing keys>>=
[ControlMap, Char.code '_'], "undo";
@

<<undoing actions>>=
define_action "undo"  undo;
@


<<function Simple.undo>>=
let undo frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in  
  let point = frame.frm_point in
  let action, at_point, len = Text.undo text in
  frame.frm_last_text_updated <- version text - 1;
  Text.set_position text point at_point;
  Text.fmove text point len; ()
@

<<[[Text.text]] other fields>>=
mutable text_history : action list;
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_history : (int * Text.action) list;
@

%\subsection{Helpers}


<<type Text.action>>=
and action =
  Insertion of int * int * int
| Deletion of int * string * int
| Session of action list
@
% for undo?


<<function Text.undo>>=
let undo tree =
  let text = tree.tree_text in  
  let rec undo action =
    let gpoint = text.text_gpoint in
    let gsize = text.text_gsize in
    match action with
      Insertion(point_pos, len, modified) ->
        let point = if gpoint < point_pos then point_pos + gsize else point_pos in
        let (pos,str,modif) = low_delete tree point len in
        text.text_modified <- modified;
        Deletion(pos,str,modif), point_pos, 0
    | Deletion (point_pos, str, modified) ->
        let point = if gpoint < point_pos then point_pos + gsize else point_pos in
        let (pos,len,modif) = low_insert tree point str in
        text.text_modified <- modified;
        Insertion(pos,len,modif), point_pos, String.length str
    | Session actions ->
        let last_point = ref 0 in
        let last_len = ref 0 in
        let rev_actions =
          List.fold_left (fun undos action -> 
              let (rev_action,point,len) = undo action in
              last_point := point;
              last_len := len;
              rev_action :: undos
          ) [] actions
        in
        Session rev_actions, !last_point, !last_len
  in
  match text.text_history with
    [] -> raise Not_found
  | action :: tail -> 
      let rev_action = undo action in
      text.text_history <- tail;
      rev_action
@


\chapter{Search and Replace}

\section{Searching}

<<searching keys>>=
[ControlMap, Char.code 's'], "isearch_forward";
[ControlMap, Char.code 'r'], "isearch_backward";
[MetaMap, Char.code 's'], "isearch_forward_regexp";
[MetaMap, Char.code 'r'], "isearch_backward_regexp";
@

<<searching actions>>=
define_action "isearch_forward"  isearch_forward;
define_action "isearch_backward"  isearch_backward;
define_action "isearch_forward_regexp"  isearch_forward_regexp;
define_action "isearch_backward_regexp"  isearch_backward_regexp;
@

<<type Efuns.sens>>=
type sens = 
  Backward | 
  Forward
@

\subsection{Strings}

<<constant Search.isearch_forward>>=
let isearch_forward = isearch RegexpString Forward
@

<<constant Search.isearch_backward>>=
let isearch_backward = isearch RegexpString Backward
@

\subsection{Regexps}

<<constant Search.isearch_forward_regexp>>=
let isearch_forward_regexp = isearch Regexp Forward
@

<<constant Search.isearch_backward_regexp>>=
let isearch_backward_regexp = isearch Regexp Backward 
@

\subsection{Helpers}

<<constant Search.last_search>>=
let last_search = ref ""
@

<<function Search.isearch>>=
let isearch to_regexp sens frame =
  let top_window = Window.top frame.frm_window in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let spoint = Text.dup_point text point in
  let orig = Text.get_position text point in
  let sens = ref sens in
  let to_regexp = ref to_regexp in
  let ismap = Keymap.create () in
  let request () =
    "isearch-"^
      (match !sens with
        Backward -> "backward"
      | Forward -> "forward"
    )^
      (match !to_regexp with
        Regexp -> "-regexp :"
      | RegexpString -> " :"
    )
  in
  let string = ref "" in
  let isearch_s () =
    last_search := !string;
    let regexp, delta =       
      if !case_fold then
        match !to_regexp with
          Regexp -> Str.regexp_case_fold !string, 0
        | RegexpString -> Str.regexp_string_case_fold
              !string, String.length !string
      else
      match !to_regexp with
        Regexp -> Str.regexp !string, 0
      | RegexpString -> Str.regexp_string !string, String.length !string
    in  
    let point = frame.frm_point in
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    goto_point text point spoint;
    match !sens with
      Backward -> 
        let _ = Text.search_backward text regexp point in ()
    | Forward ->  
        let len = Text.search_forward text regexp point in
(*        Printf.printf  "Found at %d len %d" (Text.get_position text point) len;
        print_newline ();*)
        fmove text point len; ()
  in
  let set_last mini_frame =
    if !string = "" then
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      let point = mini_frame.frm_point in
      Text.insert text point !last_search;
      Text.fmove text point (String.length !last_search);
      string := !last_search
  in
  Keymap.add_binding ismap [ControlMap, Char.code 's'] 
    (fun mini_frame ->
      set_last mini_frame;      
      Text.goto_point text spoint point;
      sens := Forward;
      isearch_s ();
      Minibuffer.update_request mini_frame (request ())
  );    
  Keymap.add_binding ismap [ControlMap, Char.code 'r']
    (fun mini_frame ->
      set_last mini_frame;      
      Text.goto_point text spoint point;
      sens := Backward;
      isearch_s ();
      Minibuffer.update_request mini_frame (request ())
  );  
  let mini_frame =
    incremental_mini_buffer frame ismap (request ()) !string
      (fun frame str -> 
        string := str;
        isearch_s ()
    )
    (fun frame str -> 
        last_search := str;
        Text.remove_point text spoint
    )
  in
  let kill_and f mini_frame =
    last_search := Text.to_string mini_frame.frm_buffer.buf_text;
    Minibuffer.kill mini_frame frame;
    f frame
  in
  Keymap.add_binding ismap [ControlMap, Char.code 'g']
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      Text.set_position frame.frm_buffer.buf_text frame.frm_point orig
  );
  Keymap.add_binding ismap [NormalMap, XK.xk_Left]
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      let _ = move_backward frame 1 in ());  
  Keymap.add_binding ismap [NormalMap, XK.xk_Right]
    (fun mini_frame  ->
      Minibuffer.kill mini_frame frame;
      let _ = move_forward frame 1 in ());  
  Keymap.add_binding ismap [NormalMap, XK.xk_Down] (kill_and forward_line);
  Keymap.add_binding ismap [NormalMap, XK.xk_Up] (kill_and backward_line);
  Keymap.add_binding ismap [ControlMap, Char.code 'a'] 
    (kill_and beginning_of_line);
  Keymap.add_binding ismap [ControlMap, Char.code 'e'] 
    (kill_and end_of_line)
@




<<function Text.search_forward>>=
let search_forward tree regexp point =
  let text = tree.tree_text in    
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= gap_end then pos - gsize else pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@


<<function Text.search_forward_matched>>=
let search_forward_matched tree regexp point =
  let text = tree.tree_text in      
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= text.text_gpoint + gsize then pos - gsize else pos in
  set_position tree point pos;
  Str.matched_string string
@

<<function Text.search_forward_groups>>=
let search_forward_groups tree regexp point groups =
  let text = tree.tree_text in      
  let gsize = text.text_gsize in
  let gap_end = text.text_gpoint + gsize in
  if point.point = text.text_gpoint then point.point <- gap_end;
  if point.point < gap_end then clean_text text;
  let gap_end = text.text_gpoint + gsize in  
  let string = text.text_string in
  let pos = Str.search_forward regexp string point.point in
  let pos = if pos >= gap_end then pos - gsize else pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@

<<function Text.search_backward>>=
let search_backward tree regexp point =
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.point > 0 then point.point - 1 
    else raise Not_found  in
  let pos =  Str.search_backward regexp string start_pos in
  set_position tree point pos;
  Str.match_end () - Str.match_beginning ()
@

<<function Text.search_backward_groups>>=
let search_backward_groups tree regexp point groups =  
  let text = tree.tree_text in    
  if point.point > text.text_gpoint then clean_text text;
  let string = text.text_string in
  let start_pos =     
    if point.point > 0 then point.point - 1 
    else raise Not_found  in
  let pos =  Str.search_backward regexp string start_pos in
  let array = Array.init groups (fun i -> Str.matched_group (i+1) string) in
  set_position tree point pos;
  array
@



\section{Replacing}

<<replacing keys>>=
[MetaMap, Char.code '%'], "query_replace_string";
@

<<replacing actions>>=
define_action "replace_string" replace_string;
define_action "replace_regexp" replace_regexp;
define_action "query_replace_string" query_replace_string;
define_action "query_replace_regexp" query_replace_regexp;
@

<<[[interactives_map]] initial entries>>=
"replace_string";
"replace_regexp";
"query_replace_string";
"query_replace_regexp";
@


%\section{Regexps}
% mv later?

<<type Efuns.to_regexp>>=
type to_regexp =
  Regexp
| RegexpString
@

<<function Efuns.string_to_regex>>=
let string_to_regex s = s, Str.regexp s
@


<<constant Efuns.regexp_option>>=
let regexp_option = define_option_class "Regexp" 
    (fun v -> match v with
        Value s ->  string_to_regex s | _ -> raise Not_found)
  (fun (s,r) -> Value s)
@
% where need that? for c_error_regexp config file

\subsection{Strings}

<<function Search.replace_string>>=
let replace_string frame =
  select_replace frame "Replace string: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace RegexpString frame NoQuery str))
@

<<function Search.query_replace_string>>=
let query_replace_string frame =
  select_replace frame "Replace string: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace RegexpString frame 
          (Query ( frame, "Replace string ? (y/n)"))
        str)
  )
@

\subsection{Regexps}

<<function Search.replace_regexp>>=
let replace_regexp frame =
  select_replace frame "Replace Regexp: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace Regexp frame NoQuery str))
@

<<function Search.query_replace_regexp>>=
let query_replace_regexp frame =
  select_replace frame "Replace regexp: " 
    (fun str ->
      select_replace frame "with string: " 
        (replace Regexp frame 
          (Query (frame, "Replace regexp ? (y/n)"))
        str))
@

\subsection{Helpers}

<<function Text.replace_matched>>=
let replace_matched tree repl =
  let text = tree.tree_text in    
  Str2.replace_matched repl text.text_string
@



\chapter{Multi-Buffers}

% will present 4 different ways to switch buffers:
%  - menu
%  - C-x b interactive
%  - C-x k to kill the current buffer (which in effect switch to next one)
%  - cycling


\section{Buffer names}

% can have ambiguity?

% Ebuffer.create -> <>
<<function Ebuffer.get_name>>=
let get_name location filename =
  let basename = Filename.basename filename in
  let name = 
    if basename = "" then
      (Filename.basename (Filename.dirname filename)) ^ "/"
    else
      basename
  in
  let i = ref 0 in
  let compute_name () =
    if !i = 0 
    then name 
    else Printf.sprintf "%s<%d>" name !i
  in
  try
    while true do
      let _ = Hashtbl.find location.loc_buffers (compute_name ()) in 
      incr i
    done; assert false
  with
    Not_found -> 
      compute_name ()
@


\section{Buffers menu}

<<[[Std_efunsrc]] buffers menu setup>>=
buffers_menu := (fun top_window button () ->
    let buffers = ref [] in
    let loc = top_window.top_location in
    Hashtbl.iter (fun name _buf -> buffers := name :: !buffers) loc.loc_buffers;
    let desc = Array.map (fun name -> 
          (name, wrap top_window (fun top_window ->
                let frame = top_window.top_active_frame in
                let window = frame.frm_window in
                Frame.change_buffer window name
            )))
      (Array.of_list !buffers) in

    (* X11 *)
    (*
    let menu = new WX_popup.t top_window.top_root desc in
    let (x,y) = button#root_coordinates in
    menu#popup_once x (y + button#height) (Some !WX_types.button_event)
    *)
    failwith "Std_menu: show menus TODO"
    )
@

\section{Changing the buffer}

%\section{Navigation}

<<buffer managment keys>>=
[c_x; NormalMap, Char.code 'b'], "change_buffer";
@
<<buffer managment actions>>=
(* C-x map *)
define_action "change_buffer"  change_buffer;
@


<<function Complex.change_buffer>>=
let change_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  select_buffer frame " Switch to buffer: " default (fun str ->
      let window = frame.frm_window in
      Frame.change_buffer window str
  )
@

<<function Frame.change_buffer>>=
let change_buffer window name = 
  let top_window = Window.top window in
  let location = top_window.top_location in
  try
    let buf = Hashtbl.find location.loc_buffers name in
    let frame = create window None  buf 
    in
    exec_named_hooks !!change_buffer_hooks frame;
    status_name frame buf.buf_name
  with
    Not_found -> ()
@


\section{Killing the buffer}

<<file menu entries>>=
"Kill Buffer", "kill_buffer";
@

<<buffer managment keys>>=
[c_x; NormalMap, Char.code 'k'], "kill_buffer";
@
<<buffer managment actions>>=
(* C-x map *)
define_action "kill_buffer"  kill_buffer;
@

<<function Simple.kill_buffer>>=
let kill_buffer frame =
  let window = frame.frm_window in
  let top_window = Window.top window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let new_buf = next_buffer location buf in
  let _new_frame = Frame.create window None new_buf in
  if buf.buf_shared = 0 
  then Ebuffer.kill location buf
@


<<function Ebuffer.kill>>=
let kill location buf =
  Hashtbl.remove location.loc_buffers buf.buf_name;
  begin
    match buf.buf_filename with
      None -> ()
    | Some filename ->
        Hashtbl.remove location.loc_files filename
  end;
  List.iter (fun f -> f () ) buf.buf_finalizers;
  Gc.compact ();
  buf.buf_shared <- -1
@

<<[[Efuns.buffer]] other fields>>=
mutable buf_finalizers : (unit -> unit) list;
@



\section{Cycling buffers}
% of frame?

<<buffer navigating keys>>=
[ControlMetaMap, XK.xk_Left], "left_buffer";
[ControlMetaMap, XK.xk_Right], "right_buffer";
[ControlMetaMap, XK.xk_Down], "down_buffer";
[ControlMetaMap, XK.xk_Up], "up_buffer";
@

<<buffer navigating actions>>=
(* C-M map *)
define_action "left_buffer"  left_buffer;
(* C-M map *)
define_action "right_buffer"  right_buffer;
(* C-M map *)
define_action "down_buffer"  down_buffer;
(* C-M map *)
define_action "up_buffer"  up_buffer;
@

<<function Complex.left_buffer>>=
let left_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window (
    match !prev_buffers with
      name :: buffer :: tail ->
        prev_buffers := tail @ [name]; 
        buffer
    | _ -> raise Not_found)
@

<<function Complex.right_buffer>>=
let right_buffer frame =
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window (match !prev_buffers with
      name :: tail ->
        begin
          match List.rev tail with
            buffer :: tail ->
              prev_buffers := name :: (List.rev tail);
              buffer
          | _ -> raise Not_found
        end
    | _ -> raise Not_found)
@


<<constant Complex.up_buffer>>=
let up_buffer = ref ""
@

<<function Complex.down_buffer>>=
let down_buffer frame = up_buffer := frame.frm_buffer.buf_name
@

<<function Complex.up_buffer>>=
let up_buffer frame =
  if !up_buffer = "" then raise Not_found;
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window !up_buffer
@

\chapter{Multi-Windows/Frames}

% recall window_down type!

% rendering:
% Top_window.update_display -> <> -> Frame.update
<<function Window.iter>>=
let iter f window = 
  let rec iter1 window =
    match window.win_down with
    | HComb (w1,w2) -> iter1 w1; iter1 w2       
    | VComb (w1,w2) -> iter1 w1; iter1 w2
    | WFrame frame -> f frame
    | NoFrame _ -> ()
  in
  iter1 window
@

\section{Creating sub windows}

<<[[edit_menu]] entries>>=
"Cut Frame", "v_cut_frame";
@

<<frame managment keys>>=
[c_x; NormalMap, Char.code '2'], "vertical_cut_frame";    
[c_x; NormalMap, Char.code '3'], "horizontal_cut_frame";    
@

<<frame managment actions>>=
(* C-x map *)
define_action "vertical_cut_frame"  v_cut_frame;    
(* C-x map *)
define_action "horizontal_cut_frame"  h_cut_frame;    
@

<<function Multi_frames.v_cut_frame>>=
let v_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let _ = Frame.create (cut_frame frame) None frame.frm_buffer in ()
@

<<function Multi_frames.h_cut_frame>>=
let h_cut_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    if window.win_width > 10 then
      let wi = window.win_width / 2 in
      let w1 = Window.create false
          (Window window) window.win_xpos window.win_ypos
          wi window.win_height in
      let w2 = Window.create false (Window window) (window.win_xpos + wi) 
        window.win_ypos
          (window.win_width - wi) window.win_height in
      window.win_down <- HComb (w1,w2);
      Frame.install w1 frame;
      let _ = Frame.create w2 None frame.frm_buffer in ()
@


\section{Deleting sub windows}

<<[[edit_menu]] entries>>=
"One Frame", "one_frame";
"Delete Frame", "delete_frame";
@
%bug? not sure v_cut_frame will work!


<<frame managment keys>>=
[c_x; NormalMap, Char.code '1'], "one_frame";
[c_x; NormalMap, Char.code '0'], "delete_frame";
@

<<frame managment actions>>=
(* C-x map *)
define_action "one_frame"  one_frame;
(* C-x map *)
define_action "delete_frame"  delete_frame;
@

<<function Multi_frames.one_frame>>=
let one_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    let top_window = Window.top window in
    if not (top_window.window == window) then
      begin
        Frame.install top_window.window frame;
        Frame.active frame
      end
@

<<function Multi_frames.delete_frame>>=
let delete_frame frame =
  if frame.frm_mini_buffer = None 
  then
    let window = frame.frm_window in
    match window.win_up with
      TopWindow _ -> ()
    | Window upwin ->
        Frame.install upwin frame;
        Frame.active frame
@

\section{Navigating windows}

<<frame navigation keys>>=
[c_x; NormalMap, Char.code 'o'], "next_frame";
@
<<frame navigation actions>>=
(* C-x map *)
define_action "next_frame"  next_frame;
@

<<function Multi_frames.next_frame>>=
let next_frame frame =
  let window = frame.frm_window in
  Window.next Frame.active window
@



<<function Window.next>>=
let rec next f window =
  match window.win_up with
    TopWindow top_window -> first f top_window.window
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w2 == window then
            next f win
          else
            first f w2
      | VComb (w1,w2) ->
          if w2 == window then
            next f win
          else
            first f w2
      | _ -> ()
@


%\section{Navigation}


% ?? -> <>
<<function Window.first>>=
let rec first f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> first f w1
  | VComb (w1,w2) -> first f w1
  | NoFrame _ -> ()
@

% ?? -> <>
<<function Window.last>>=
let rec last f window =
  match window.win_down with
    WFrame frame -> f frame
  | HComb (w1,w2) -> last f w2
  | VComb (w1,w2) -> last f w2
  | NoFrame _ -> ()
@


% ?? -> <>
<<function Window.prev>>=
let rec prev f window =
  match window.win_up with
    TopWindow top_window -> 
      if window == top_window.window then ()
      else 
        last f top_window.window
  | Window win ->
      match win.win_down with
        HComb (w1,w2) ->
          if w1 == window then
            prev f win
          else
            last f w1
      | VComb (w1,w2) ->
          if w1 == window then
            prev f win
          else
            last f w1
      | _ -> ()
@



\section{Windows windows XXX}

<<constant Keymap.n_5>>=
let n_5 = (NormalMap, Char.code '5')
@

<<window managment keys>>=
[c_x; n_5; NormalMap, Char.code 'f'], "window_load_buffer";
[c_x; n_5; NormalMap, Char.code 'b'], "window_change_buffer";
[c_x; n_5; NormalMap, Char.code '0'], "delete_window";
@

<<window managment actions>>=
(* C-x 5 map *)
define_action "window_load_buffer"  window_load_buffer;
(* C-x 5 map *)
define_action "window_change_buffer"  window_change_buffer;
(* C-x 5 map *)
define_action "delete_window"  Top_window.delete_window;
@


<<function Complex.window_load_buffer>>=
let window_load_buffer frame = 
  select_filename frame "Find file: " 
    (fun str -> 
      let top_window = Window.top frame.frm_window in
      let top_window = Top_window.create top_window.top_location
          (Window.display top_window)
      in
      let _ = Frame.load_file top_window.window str in ())
@

<<function Complex.window_change_buffer>>=
let window_change_buffer frame =
  select_buffer frame "Switch to buffer in new frame: " 
    (get_previous_frame ())
  (fun name ->
      let top_window = Window.top frame.frm_window in
      let top_window = Top_window.create 
          top_window.top_location (Window.display top_window) in
      Frame.change_buffer top_window.window name
  )
@

<<function Top_window.delete_window>>=
let delete_window frame =
  failwith "Top_window:delete_window: TODO"
(*
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  if List.length location.top_windows > 1 then
    let xterm = Window.xterm top_window in
    top_window.top_appli#destroy;
    WX_xterm.destroy_window xterm;
    Frame.kill_all top_window.window;
    location.top_windows <- Utils.list_remove location.top_windows
      top_window
*)
@

<<function Frame.kill_all>>=
let kill_all window =
  Window.iter kill window
@

<<[[Efuns.frame]] other fields>>=
mutable frm_killed : bool;
@

%XXX
<<function Frame.kill>>=
let kill frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  frame.frm_killed <- true;
  buf.buf_shared <- buf.buf_shared - 1;
  Text.remove_point text buf.buf_point;
  Text.remove_point text buf.buf_start;
  buf.buf_point <- frame.frm_point;
  buf.buf_start <- frame.frm_start
@


\chapter{Major Modes}


<<[[Efuns.buffer]] other fields>>=
mutable buf_major_mode : major_mode;
@
% note that major mode is a property of the buffer! not the frame.

<<[[Efuns.status]] other fields>>=
mutable stat_mode : major_mode;
@


<<type Efuns.major_mode>>=
and major_mode = {
    maj_name : string;
    maj_map : map;

    mutable maj_hooks : (buffer -> unit) list;
    mutable maj_vars : vars;
  }
@

<<function Ebuffer.new_major_mode>>=
let new_major_mode name hooks = {
    maj_name = name;
    maj_map = Keymap.create ();
    maj_hooks = hooks;
    maj_vars = Local.vars ();
  }
@



<<function Ebuffer.set_major_mode>>=
let set_major_mode buf mode =
  buf.buf_modified <- buf.buf_modified + 1;
  buf.buf_major_mode <- mode;
  List.iter (fun f -> try f buf with _ -> ()) mode.maj_hooks
@



\section{Fundamental mode}

<<[[interactives_map]] initial entries>>=
"fondamental_mode";
@

<<major mode actions>>=
define_action "fondamental_mode" fondamental_mode;
@

<<function Std_efunsrc.fondamental_mode>>=
let fondamental_mode frame =
  Ebuffer.set_major_mode frame.frm_buffer Ebuffer.fondamental_mode
@

<<constant Ebuffer.fondamental_mode>>=
let fondamental_mode = new_major_mode "Fondamental" [] (* no hooks *)
@

\section{Auto detection}

<<constant Ebuffer.modes_alist>>=
let modes_alist = Local.create_abstr "modes_alist"
@


<<constant Ebuffer.regexp_alist>>=
let regexp_alist = ref []
@

<<function Ebuffer.modep>>=
let modep buf minor =
  List.memq minor buf.buf_minor_modes
@

<<constant Ebuffer.suffix_reg>>=
let suffix_reg = Str.regexp "\(.*\)<[0-9]+>$"
@
%$

<<function Ebuffer.set_buffer_mode>>=
let set_buffer_mode buf =
  let buf_name = 
    match buf.buf_filename with
      None -> 
        (try
          if Str.string_match suffix_reg buf.buf_name 0 then
            Str.matched_group 1 buf.buf_name else buf.buf_name 
        with
          _ -> buf.buf_name)
    | Some file_name -> file_name 
  in 
  let modes_alist = get_var buf modes_alist in
  if not (!modes_old == modes_alist) then
    begin
      regexp_alist := 
      List.map 
        (fun (file_reg, major) ->
          Str.regexp file_reg, major) modes_alist;
      modes_old := modes_alist;
    end;
  try
    List.iter (fun (regexp, major) ->
        if Str.string_match regexp buf_name 0 then
          try
            set_major_mode buf major;
            raise Exit
          with
            _ -> raise Exit
    ) !regexp_alist
  with
    Exit -> ()
@


\section{Status line}

<<[[Frame.create_without_top()]] adjust status of frame>>=
status_major_mode frame;
@

<<function Frame.status_major_mode>>=
let status_major_mode frame  =
  let buf = frame.frm_buffer in
  let status = frame.frm_status in
  if not (status.stat_modes == buf.buf_minor_modes &&
          status.stat_mode == buf.buf_major_mode
    ) then
    begin
      status.stat_modes <- buf.buf_minor_modes;
      status.stat_mode <- buf.buf_major_mode;
      status_print status (Printf.sprintf "(%s)" 
          (print_list
            (buf.buf_major_mode.maj_name ::
            (List.map (fun m -> m.min_name) status.stat_modes))))
      StatMode;
    end
@

\section{Major mode variables and keys}

<<function Efuns.set_major_var>>=
let set_major_var maj var value = Local.set maj.maj_vars var value
@

<<function Keymap.add_major_key>>=
let add_major_key major = interactive major.maj_map 
@


<<[[Ebuffer.get_binding()]] major mode key search>>=
(let b = Keymap.get_binding buf.buf_major_mode.maj_map keylist in
  match b with
    Prefix map -> binding := b
  | Function f -> binding := b; raise Exit
  | Unbound -> ());
@

<<[[Efuns.get_var()]] try with major mode variables>>=
Local.get buf.buf_major_mode.maj_vars var
@

\chapter{Minor Modes}

<<[[Efuns.buffer]] other fields>>=
mutable buf_minor_modes : minor_mode list;
@

<<[[Efuns.status]] other fields>>=
mutable stat_modes : minor_mode list;
@

<<type Efuns.minor_mode>>=
and minor_mode = {
    min_name : string;
    min_map : map;

    mutable min_hooks : (buffer -> unit) list;
    mutable min_vars : vars;
  }
@

<<function Ebuffer.new_minor_mode>>=
let new_minor_mode name = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = [];
    min_vars = Local.vars ()
  }
@
% dead?

<<function Ebuffer.new_minor_mode (core/ebuffer.ml)>>=
let new_minor_mode name hooks  = {
    min_name = name;
    min_map = Keymap.create ();
    min_hooks = hooks;
    min_vars = Local.vars ()
  }
@


<<function Ebuffer.set_minor_mode>>=
let set_minor_mode buf mode =
  buf.buf_minor_modes <- mode :: buf.buf_minor_modes;
  buf.buf_modified <- buf.buf_modified + 1;
  List.iter (fun f -> try f buf with _ -> ()) mode.min_hooks
@

<<function Ebuffer.del_minor_mode>>=
let del_minor_mode buf minor =
  buf.buf_minor_modes <- 
    List.fold_right 
    (fun mode list -> 
      if mode == minor then
        begin
          buf.buf_modified <- buf.buf_modified + 1;
          list
        end
      else (mode :: list)) buf.buf_minor_modes []
@



\section{Example}

<<constant Minor_mode_sample.minor_mode_name>>=
let minor_mode_name = "my_minor_mode"
@

% empty install hook
<<function Minor_mode_sample.install>>=
let install buf = ()
@

<<function Minor_mode_sample.minor_mode_fun>>=
let minor_mode_fun frame = ()
@

<<constant Minor_mode_sample.mode>>=
let mode = Ebuffer.new_minor_mode  minor_mode_name [install]
@

<<toplevel Minor_mode_sample._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, Char.code key]
        minor_mode_fun
  )
  [ ]
@

<<toplevel Minor_mode_sample._2>>=
let _ = 
  define_action (minor_mode_name ^ "_mode")
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
    )
@


\section{Minor mode variables and keys}

<<function Efuns.set_minor_var>>=
let set_minor_var min var value = Local.set min.min_vars var value
@

<<function Keymap.add_minor_key>>=
let add_minor_key minor = interactive minor.min_map 
@



<<[[Ebuffer.get_binding()]] minor mode key search>>=
List.iter (fun minor ->
    let b = Keymap.get_binding minor.min_map keylist in
    match b with
      Prefix map -> binding := b
    | Function f -> binding := b; raise Exit
    | Unbound -> ()
) buf.buf_minor_modes; 
@

<<[[Efuns.get_var()]] try with minor mode variables>>=
let rec iter list =
  match list with
    [] -> raise Not_found
  | min :: list -> 
      try
        Local.get min.min_vars var
      with _ -> iter list
in
iter buf.buf_minor_modes
@


\chapter{Other Features}

\section{External commands}

<<external commands keys>>=
[MetaMap, Char.code '!'], "shell_command";
@

<<external command actions>>=
define_action "shell_command"  shell_command;
@

<<function System.shell_command>>=
let shell_command frame =
  select_string frame "Run command:" shell_hist ""
    (fun cmd -> let _ = start_command "*Command*" (cut_frame frame) cmd in ())
@


\section{Compilation and grep mode}

<<file menu entries>>=
"Compile", "compile";
@

<<misc keys>>=
[c_x;NormalMap, Char.code '`' ], "next_error";
@

<<misc actions>>=
(* C-x map *)
define_action "next_error"  next_error;
@

<<external command actions>>=
define_action "grep" grep;
(*  define_action "compile" (compile c_find_error); *)
@

<<[[interactives_map]] initial entries>>=
"compile";
"grep";
@

\subsection{[[M-x grep]]}

<<constant Std_efunsrc.grep_hist>>=
let grep_hist = ref ["grep -n "]
@

<<function Compil.grep>>=
let grep frame =
  let default = List.hd !grep_hist in
  select_string frame (Printf.sprintf "Grep command: %s (default: %s) " !!grep_command default)
  grep_hist ""
    (fun cmd -> 
      let cmd = if cmd = "" then default else cmd in
      let cmd = !!grep_command ^ " " ^ cmd in
      let cdir = Frame.current_dir frame in
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let comp_window =
        match !compilation_frame with
          None -> cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill location new_frame.frm_buffer;
            if new_frame.frm_killed 
            then cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Grep*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.add_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error c_find_error
  )
@

\subsection{[[M-x compile]]}

<<function Std_efunsrc.compile>>=
let compile frame =
  exec_interactive (buf_interactives frame.frm_buffer) frame "compile"
@

<<misc actions>>=
define_action "compile" compile;
@

<<function Compil.compile>>=
let compile find_error_fun frame =
  let default = List.hd !make_hist in
  select_string frame ("Compile command: (default :"^ default^") " )
  make_hist ""
    (fun cmd -> 
      let cmd = 
        if cmd = "" then default else
          cmd 
      in
      let cdir = Frame.current_dir frame in
      let cdir = 
        if !!compile_find_makefile then
          if String.sub cmd 0 4 = "make" || String.sub cmd 1 4 = "make" then
          (* try to find a Makefile in the directory *)
            let rec iter dir =
              let m = Filename.concat dir "Makefile" in
              if Sys.file_exists m then dir else
              let m = Filename.concat dir "makefile" in
              if Sys.file_exists m then dir else                
              let m = Filename.concat dir "GNUmakefile" in
              if Sys.file_exists m then dir else 
              let newdir = Filename.dirname dir in
              if newdir = dir then cdir else iter newdir
            in
            iter cdir
          else
            cdir
        else cdir
      in
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let comp_window =
        match !compilation_frame with
          None -> cut_frame frame 
        | Some (new_frame,error_point, _) ->
            Text.remove_point new_frame.frm_buffer.buf_text error_point;
            Ebuffer.kill location new_frame.frm_buffer;
            if new_frame.frm_killed 
            then cut_frame frame
            else new_frame.frm_window 
      in
      Unix.chdir cdir;
      let comp_frame = System.start_command "*Compile*" comp_window cmd in
      Frame.active frame;
      let buf = comp_frame.frm_buffer in
      let error_point = Text.add_point buf.buf_text in
      compilation_frame := Some (comp_frame, error_point, cdir);
      set_local buf find_error find_error_fun
  )
@


<<function Compil.next_error>>=
let next_error top_frame =
  let top_window = Window.top top_frame.frm_window in
  let location = top_window.top_location in
  match !compilation_frame with
    None -> Top_window.message top_window "No compilation started"
  | Some (frame, error_point, cdir) ->      
      if frame.frm_killed 
      then unkill (cut_frame top_frame) frame;
      let buf = frame.frm_buffer in
      let find_error = try
          get_local buf find_error
        with Failure _ -> !default_error
      in
      let text = buf.buf_text in
      let point = frame.frm_point in
      try
        let error = find_error text error_point in
        Text.set_position text frame.frm_start error.err_msg;
        Text.set_position text point error.err_msg;
        frame.frm_force_start <- true;
        frame.frm_redraw <- true;
        if error.err_filename <> "" then
          let filename = Filename.concat cdir error.err_filename in
          let buf = Ebuffer.read location filename (Keymap.create ()) in
(* new frame for error buffer *)
          let frame = 
            try find_buffer_frame location buf with Not_found ->
                if frame == top_frame then
                  let display = Window.display top_window in
                  let new_window = 
                    Top_window.create top_window.top_location 
                      display 
                  in
                  Frame.create new_window.window None buf
                else
                  Frame.create top_frame.frm_window None buf
          in
          let text = buf.buf_text in
          let point = frame.frm_point in
          Text.point_to_line text point error.err_line;
          Text.fmove text point error.err_begin;
          Frame.active frame
      with
        Not_found ->
          Top_window.message top_window "No more errors"
@

\section{Efuns server and client}

% dual of previous chapter in some sense since this time
% it's external command that call in efuns instead of efuns
% calling external commands

\section{[[M-x eval]]}

<<meta actions>>=
define_action "eval" Complex.eval;  
@
<<[[interactives_map]] initial entries>>=
"eval";  
@

<<constant Complex.eval_history>>=
let eval_history = ref []
@

<<function Complex.eval>>=
let eval frame =
  select_string frame "Eval:" eval_history "" 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      (* This is not enough: the paths also may have changed. *)
      Top_window.message top_window 
        (*(Dyneval.eval 
          (let len = String.length str in
          if str.[len - 1] = ';' && str.[len -2 ] = ';' then str else
          str ^ " ;;"))
        *)(failwith "Complex.eval: TODO")
    )
@


\section{Completion}

%Expansion des abbreviations: 
%deux fonctions principales: 
%- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
%     buffers (binding normap "M-/").
%- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
%    dans des tables associees au buffer (variable "abbrev_table") 
%    (binding normal: un caractere de fin de mot (espace,newline,..))

<<misc keys>>=
[NormalMap, Char.code ' '], "char_expand_abbrev";
[MetaMap, Char.code '/'], "dabbrev_expand";
@

<<toplevel Abbrevs._1>>=
let _ =
  define_action "char_expand_abbrev" (fun frame ->
      expand_sabbrev frame; self_insert_command frame);
  define_action "dabbrev_expand" dabbrev_expand;
  ()
@

<<function Abbrevs.expand_sabbrev>>=
let expand_sabbrev frame =
  try
    let point = frame.frm_point in
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let abbrevs = get_local buf abbrev_table in
    let mark = dup_point text point in
    to_begin_of_word text point buf.buf_syntax_table;
    let str = Text.region text point mark in
    Text.remove_point text mark;
    let len = String.length str in
    try
      let repl = Hashtbl.find abbrevs str in
      Text.delete text point len;
      Text.insert text point repl;
      fmove text point (String.length repl); ()
    with
      Not_found -> fmove text point len; ()
  with
    _ -> ()
@

<<function Abbrevs.dabbrev_expand>>=
let dabbrev_expand frame = 
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let syntax = buf.buf_syntax_table in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let loop = ref false in
  let s, buf, pos, history =
    match !dabbrev_buf with
      Some (s, for_frame, for_position, for_len,buf, pos, history) 
      when frame == for_frame && for_position = get_position text point ->
        bmove text point for_len;
        Text.delete text point for_len;
        s, buf, pos, history
    | _ -> 
        let str = beginning_of_word buf point in
        str , buf, 
        get_position text point - String.length str, []
  in
  let truelen = String.length s in
  let s = escaped s in
  bmove text point truelen;
  let regexp = Str.regexp s in
  let rec iter curr_buf pos =
    let curr_text = curr_buf.buf_text in
    let mark = add_point curr_text in
    set_position curr_text mark pos;
    try
      let rec restart () =
        let len = Text.search_backward curr_text regexp mark in
        if curr_text == text && mark = point then
          raise Exit
        else
          if bmove_res curr_text mark 1 <> 0 then
            if syntax.(Char.code (get_char curr_text mark)) then
              (fmove curr_text mark 1; restart ())
            else
              (fmove curr_text mark 1; ())
          else
            ()
      in
      let rec first () =
        restart ();
        fmove curr_text mark truelen;
        let m = end_of_word curr_buf mark in
        if List.mem m history then
          (bmove curr_text mark truelen; first ())
        else
          begin
            fmove text point truelen;
            let _,len = Text.insert_res text point m in
            fmove text point len;
            dabbrev_buf := Some (s, frame, get_position text point, len, 
              curr_buf, get_position curr_text mark, m :: history);
            remove_point curr_text mark
          end
      in
      first ()
    with
      Not_found ->
        remove_point curr_text mark;
        let curr_buf = next_buffer location curr_buf in
        if curr_buf == buf then
          if !loop then raise Not_found
          else
            loop := true; (* to avoid infinite loop *)
        iter curr_buf (Text.size curr_buf.buf_text) 
    | Exit ->
        remove_point curr_text mark;
        fmove text point truelen;
        dabbrev_buf := None;
        raise Not_found
  in
  iter buf pos; ()
@


<<constant Abbrevs.dabbrev_buf>>=
let dabbrev_buf = ref None
@

<<constant Abbrevs.abbrev_table>>=
let abbrev_table = Local.create "abbrev_table" 
    (fun table ->
      let s = ref "" in 
      Hashtbl.iter (fun s1 s2 ->
          s := Printf.sprintf "%s%s --> %s\n" !s s1 s2
      ) table;
      !s
  )
  Local.no_input
@

<<function Abbrevs.escaped>>=
let escaped s =
  let n = ref 0 in
  let len = String.length s in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    match c with
      '\\' | '[' | ']' | '^' -> incr n
    | _ -> ()
  done;
  if !n = 0 then s else
  let ss = String.create (len + !n) in
  let p = ref 0 in
  for i = 0 to len - 1 do
    let c = String.unsafe_get s i in
    (match c with
        '\\' | '[' | ']' | '^' -> 
          String.unsafe_set ss !p '\\';
          incr p
      | _ -> ());
    String.unsafe_set ss !p c;
    incr p    
  done;
  ss
@

\section{Transforming}
% maybe move in extra features?

<<transforming keys>>=
[ControlMap, Char.code 't'], "transpose_chars";

[MetaMap, Char.code 't'], "transpose_words";
[MetaMap, Char.code 'l'], "lowercase_word";
[MetaMap, Char.code 'u'], "uppercase_word";

[MetaMap, XK.xk_q], "fill_paragraph";
@

<<transforming actions>>=
define_action "transpose_chars"  (to_frame transpose_chars);

define_action "transpose_words"  (to_frame transpose_words);
define_action "lowercase_word" 
  (fun frame ->
    let buf = frame.frm_buffer in
    let point = frame.frm_point in
    on_word buf point String.lowercase);
define_action "uppercase_word" 
  (fun frame ->
    let buf = frame.frm_buffer in
    let point = frame.frm_point in
    on_word buf point String.uppercase);

define_action "fill_paragraph" fill_paragraph;
@

\subsection{Characters}

<<function Simple.transpose_chars>>=
let transpose_chars buf point =
  let text = buf.buf_text in
  let session = start_session text in
  bmove text point 1;
  let pos,c1 = Text.delete_res text point 1 in
  fmove text point 1;
  let _ = Text.insert text point c1 in
  commit_session text session;
  fmove text point 1;
  ()
@

\subsection{Words}
%\subsection{Case changing}

<<function Simple.transpose_words>>=
let transpose_words buf point =
  let text = buf.buf_text in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  in_prev_word text point syntax;
  to_begin_of_word text point syntax;
  let pos1 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (distance text pos1 point) in
  goto_point text point pos1;
  in_next_word text point syntax;
  let pos2 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word2 = Text.delete_res text pos2 (distance text pos2 point) in    
  let _ = Text.insert text pos1 word2 in
  let _ = Text.insert text pos2 word1 in
  fmove text point (String.length word1);
  commit_session text session;
  remove_point text pos1;
  remove_point text pos2
@

<<function Simple.on_word>>=
let on_word buf point f =
  let text = buf.buf_text in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  to_begin_of_word text point syntax;
  let pos1 = dup_point text point in
  to_end_of_word text point syntax;
  let _,word1 = Text.delete_res text pos1 (distance text pos1 point) in
  let w = f word1 in
  let _ = Text.insert text pos1 w in
  fmove text point (String.length w);
  commit_session text session;
  remove_point text pos1
@

\subsection{Filling}

<<function Simple.fill_paragraph>>=
(* We will have to modify this to handle line_comment soon !! *)
let fill_paragraph frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let start = dup_point text point in
  let session = start_session text in
  let syntax = buf.buf_syntax_table in
  backward_paragraph buf start;
  let fin = dup_point text start in
  forward_paragraph buf fin;
  simplify text start fin;
  let _ = insert text start "\n" in
  let rec iter count last_space =
    if compare text start fin < 0 then
    if fmove_res text start 1 = 1 then 
      let c = get_char text start in  
        if c = ' ' then (* good, a new space *)
          iter (count+1) 0
      else
      if count > 75 && count <> last_space then 
          begin
          bmove text start (last_space+1);
          delete text start 1;
          insert text start "\n";
          fmove text start 1;
          iter 0 0
          end
        else
          iter (count+1) (last_space+1)
  in
  iter 0 0;  
  let _ = insert text fin "\n" in
  remove_point text start;
  remove_point text fin;
  commit_session text session
@


\section{Misc}

\subsection{Read-only}

<<[[Text.text]] other fields>>=
mutable text_readonly : bool;
@

<<function Text.readonly>>=
let readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly
@

% dead since not one calls it and it's not an action
<<function Text.toggle_readonly>>=
let toggle_readonly tree = 
  let text = tree.tree_text in    
  text.text_readonly <- not text.text_readonly
@

<<[[Text.low_insert()]] fail if readonly buffer>>=
if text.text_readonly 
then failwith "Buffer is read-only";
@

\chapter{Advanced Topics}

\section{Signals}

<<exception Main.SigInt>>=
exception SigInt
@

<<toplevel Main._1>>=
let _ =
  Utils.register_exn (fun e ->
      match e with
        Unix.Unix_error (error,f,arg) ->
          Printf.sprintf "Unix error %s: %s %s" 
            f (Unix.error_message error) arg
      | _ -> raise e);

  Utils.set_signal Sys.sigint (Sys.Signal_handle (fun _ ->  
        (* Should auto-save all buffers, and then exit ... *)
        exit 1)); 
  Utils.set_signal Sys.sigterm (Sys.Signal_handle 
      (fun _ ->  
        (* Should auto-save all buffers, and then exit ... *)
        raise SigInt));
  Utils.set_signal Sys.sighup (Sys.Signal_handle (fun _ ->  raise SigInt))
@

\section{Dynamic linking}

<<[[main()]] command line options>>=
  "-I",Arg.String (fun s -> load_path =:= 
      (string_to_path s) @ !!load_path), "<path>: Load Path";
@
%dead? or for dynlink?

<<constant Efuns.load_path>>=
let load_path = define_option ["efuns_path"] 
  "<load_path> is the path where modules (.cmo and .cma) can be found
  for dynamic linking." path_option []
@

<<constant Efuns.path>>=
let path = (*Dyneval.load_path*) ref []
@

<<constant Efuns.efuns_path>>=
let efuns_path = [ 
      (Filename.concat homedir ".efuns") ;
(*
      Version.efuns_lib; 
      Version.installdir; 
      Version.ocamllib
*)
  ]
@

<<toplevel Efuns._1>>=
let _ = 
  path := !!load_path @ efuns_path;
  option_hook load_path (fun _ -> path := !!load_path @ efuns_path)
@

\section{X11}

<<constant Efuns.xdefaults>>=
let xdefaults = try Sys.getenv "XUSERFILESEARCHPATH" with
    Not_found -> Filename.concat Utils.homedir ".Xdefaults"
@

<<toplevel Efuns._2>>=
(*
let _ =
  begin    
    try
      let efuns_res = 
        let path = try Utils.string_to_path (Sys.getenv "XFILESEARCHPATH") with _ -> 
              [] in
        let xenv = try Sys.getenv "XENVIRONMENT" with _ -> "" in
        let xroot = try Filename.concat  (Sys.getenv "X11ROOT")
            "lib/X11/app-defaults/" with _ -> "" in
        Utils.find_in_path (path@[
            xenv; xroot; "/usr/X11/lib/X11/app-defaults/"]) "Efuns"
      in
      Xrm.safe_load x_res efuns_res
    with _ -> ()
  end;
  Xrm.safe_load x_res xdefaults
*)
@

<<constant Efuns.x_res>>=
(*let x_res = Xrm.create ()*)
@

<<constant Efuns.t>>=
(*let t = x_res*)
@

\chapter{Conclusion}








\appendix

\chapter{Error Managment}

<<function Ebuffer.message>>=
let message buf m =
  let location = buf.buf_location in
  let name = "*Messages*" in
  try
    let buf = Hashtbl.find location.loc_buffers name in
    Text.insert_at_end buf.buf_text (m^"\n");
  with
    Not_found ->
      let _buf = 
        create location name None (Text.create (m^"\n")) (Keymap.create ())
      in ()
@



\chapter{Debugging}

%less: would be good to have a -debug_init so at least print out
% all those hooks that are run at startup time

\chapter{Profiling}

\chapter{Configuration File Library}

% options.ml
% quite important, you want the editor to be customizable!

\chapter{Major mode examples}

% not here:
%  - makefile
%  - ocaml toplevel
% via ocamllex:
%  - html
%  - C
%  - ocaml
%  - tex

<<[[interactives_map]] initial entries>>=
"makefile_mode";
"ocaml_mode";
"tex_mode";
"c_mode";
@

\section{Dired}

\section{Lisp mode}

\chapter{Minor mode examples}

<<[[interactives_map]] initial entries>>=
"paren_mode";
"abbrevs_mode";
"accents_mode";
"ocaml_minor_mode";
"fill_mode";
"ocaml_compiler_mode";
"tab_mode";
"overwrite_mode";
@

\section{Abbrevs}

\section{Paren}
% useful! edwin power!

\section{Tab}

\section{Fill}

%\section{Accents}



\chapter{Extra Code}

\ifallcode
#include "Efuns_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

